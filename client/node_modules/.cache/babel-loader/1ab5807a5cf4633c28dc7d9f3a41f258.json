{"ast":null,"code":"!function (e, t) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? t(exports) : \"function\" == typeof define && define.amd ? define([\"exports\"], t) : t(((e = e || self).prettierPlugins = e.prettierPlugins || {}, e.prettierPlugins.angular = {}));\n}(this, function (e) {\n  \"use strict\";\n\n  var t = function (e) {\n    return e.length > 0 ? e[e.length - 1] : null;\n  };\n\n  var n = {\n    locStart: function e(t, n) {\n      return !(n = n || {}).ignoreDecorators && t.declaration && t.declaration.decorators && t.declaration.decorators.length > 0 ? e(t.declaration.decorators[0]) : !n.ignoreDecorators && t.decorators && t.decorators.length > 0 ? e(t.decorators[0]) : t.__location ? t.__location.startOffset : t.range ? t.range[0] : \"number\" == typeof t.start ? t.start : t.loc ? t.loc.start : null;\n    },\n    locEnd: function e(n) {\n      var i = n.nodes && t(n.nodes);\n      if (i && n.source && !n.source.end && (n = i), n.__location) return n.__location.endOffset;\n      var r = n.range ? n.range[1] : \"number\" == typeof n.end ? n.end : null;\n      return n.typeAnnotation ? Math.max(r, e(n.typeAnnotation)) : n.loc && !r ? n.loc.end : r;\n    }\n  };\n\n  function i(e) {\n    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, \"default\") ? e.default : e;\n  }\n\n  function r(e, t) {\n    return e(t = {\n      exports: {}\n    }, t.exports), t.exports;\n  }\n\n  function s(e) {\n    return (s = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (e) {\n      return typeof e;\n    } : function (e) {\n      return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n    })(e);\n  }\n\n  function a(e, t) {\n    if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n  }\n\n  function o(e, t) {\n    for (var n = 0; n < t.length; n++) {\n      var i = t[n];\n      i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(e, i.key, i);\n    }\n  }\n\n  function u(e, t, n) {\n    return t && o(e.prototype, t), n && o(e, n), e;\n  }\n\n  function l(e, t) {\n    if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function\");\n    e.prototype = Object.create(t && t.prototype, {\n      constructor: {\n        value: e,\n        writable: !0,\n        configurable: !0\n      }\n    }), t && h(e, t);\n  }\n\n  function c(e) {\n    return (c = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {\n      return e.__proto__ || Object.getPrototypeOf(e);\n    })(e);\n  }\n\n  function h(e, t) {\n    return (h = Object.setPrototypeOf || function (e, t) {\n      return e.__proto__ = t, e;\n    })(e, t);\n  }\n\n  function p(e, t) {\n    return !t || \"object\" != typeof t && \"function\" != typeof t ? function (e) {\n      if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n      return e;\n    }(e) : t;\n  }\n\n  function v(e, t) {\n    return function (e) {\n      if (Array.isArray(e)) return e;\n    }(e) || function (e, t) {\n      if (!(Symbol.iterator in Object(e) || \"[object Arguments]\" === Object.prototype.toString.call(e))) return;\n      var n = [],\n          i = !0,\n          r = !1,\n          s = void 0;\n\n      try {\n        for (var a, o = e[Symbol.iterator](); !(i = (a = o.next()).done) && (n.push(a.value), !t || n.length !== t); i = !0);\n      } catch (e) {\n        r = !0, s = e;\n      } finally {\n        try {\n          i || null == o.return || o.return();\n        } finally {\n          if (r) throw s;\n        }\n      }\n\n      return n;\n    }(e, t) || function () {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }();\n  }\n\n  var f = r(function (e, t) {\n    var n = \"\\n\",\n        i = \"\\r\",\n        r = function () {\n      function e(e) {\n        this.string = e;\n\n        for (var t = [0], r = 0; r < e.length;) switch (e[r]) {\n          case n:\n            r += n.length, t.push(r);\n            break;\n\n          case i:\n            e[r += i.length] === n && (r += n.length), t.push(r);\n            break;\n\n          default:\n            r++;\n        }\n\n        this.offsets = t;\n      }\n\n      return e.prototype.locationForIndex = function (e) {\n        if (e < 0 || e > this.string.length) return null;\n\n        for (var t = 0, n = this.offsets; n[t + 1] <= e;) t++;\n\n        return {\n          line: t,\n          column: e - n[t]\n        };\n      }, e.prototype.indexForLocation = function (e) {\n        var t = e.line,\n            n = e.column;\n        return t < 0 || t >= this.offsets.length ? null : n < 0 || n > this.lengthOfLine(t) ? null : this.offsets[t] + n;\n      }, e.prototype.lengthOfLine = function (e) {\n        var t = this.offsets[e];\n        return (e === this.offsets.length - 1 ? this.string.length : this.offsets[e + 1]) - t;\n      }, e;\n    }();\n\n    t.__esModule = !0, t.default = r;\n  });\n  i(f);\n  var d = r(function (e, t) {\n    Object.defineProperty(t, \"__esModule\", {\n      value: !0\n    });\n\n    t.Context = function e(t) {\n      a(this, e), this.text = t, this.locator = new n(this.text);\n    };\n\n    var n = function () {\n      function e(t) {\n        a(this, e), this._lineAndColumn = new f.default(t);\n      }\n\n      return u(e, [{\n        key: \"locationForIndex\",\n        value: function (e) {\n          var t = this._lineAndColumn.locationForIndex(e);\n\n          return {\n            line: t.line + 1,\n            column: t.column\n          };\n        }\n      }]), e;\n    }();\n  });\n  i(d);\n  d.Context;\n  /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n\n  var y = function e(t, n, i, r) {\n    a(this, e), this.input = n, this.errLocation = i, this.ctxLocation = r, this.message = \"Parser Error: \".concat(t, \" \").concat(i, \" [\").concat(n, \"] in \").concat(r);\n  },\n      x = function e(t, n) {\n    a(this, e), this.start = t, this.end = n;\n  },\n      g = function () {\n    function e(t) {\n      a(this, e), this.span = t;\n    }\n\n    return u(e, [{\n      key: \"visit\",\n      value: function (e) {\n        return null;\n      }\n    }, {\n      key: \"toString\",\n      value: function () {\n        return \"AST\";\n      }\n    }]), e;\n  }(),\n      k = function (e) {\n    function t(e, n, i, r) {\n      var s;\n      return a(this, t), (s = p(this, c(t).call(this, e))).prefix = n, s.uninterpretedExpression = i, s.location = r, s;\n    }\n\n    return l(t, e), u(t, [{\n      key: \"visit\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;\n        return e.visitQuote(this, t);\n      }\n    }, {\n      key: \"toString\",\n      value: function () {\n        return \"Quote\";\n      }\n    }]), t;\n  }(g),\n      m = function (e) {\n    function t() {\n      return a(this, t), p(this, c(t).apply(this, arguments));\n    }\n\n    return l(t, e), u(t, [{\n      key: \"visit\",\n      value: function (e) {}\n    }]), t;\n  }(g),\n      w = function (e) {\n    function t() {\n      return a(this, t), p(this, c(t).apply(this, arguments));\n    }\n\n    return l(t, e), u(t, [{\n      key: \"visit\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;\n        return e.visitImplicitReceiver(this, t);\n      }\n    }]), t;\n  }(g),\n      C = function (e) {\n    function t(e, n) {\n      var i;\n      return a(this, t), (i = p(this, c(t).call(this, e))).expressions = n, i;\n    }\n\n    return l(t, e), u(t, [{\n      key: \"visit\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;\n        return e.visitChain(this, t);\n      }\n    }]), t;\n  }(g),\n      P = function (e) {\n    function t(e, n, i, r) {\n      var s;\n      return a(this, t), (s = p(this, c(t).call(this, e))).condition = n, s.trueExp = i, s.falseExp = r, s;\n    }\n\n    return l(t, e), u(t, [{\n      key: \"visit\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;\n        return e.visitConditional(this, t);\n      }\n    }]), t;\n  }(g),\n      b = function (e) {\n    function t(e, n, i) {\n      var r;\n      return a(this, t), (r = p(this, c(t).call(this, e))).receiver = n, r.name = i, r;\n    }\n\n    return l(t, e), u(t, [{\n      key: \"visit\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;\n        return e.visitPropertyRead(this, t);\n      }\n    }]), t;\n  }(g),\n      A = function (e) {\n    function t(e, n, i, r) {\n      var s;\n      return a(this, t), (s = p(this, c(t).call(this, e))).receiver = n, s.name = i, s.value = r, s;\n    }\n\n    return l(t, e), u(t, [{\n      key: \"visit\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;\n        return e.visitPropertyWrite(this, t);\n      }\n    }]), t;\n  }(g),\n      E = function (e) {\n    function t(e, n, i) {\n      var r;\n      return a(this, t), (r = p(this, c(t).call(this, e))).receiver = n, r.name = i, r;\n    }\n\n    return l(t, e), u(t, [{\n      key: \"visit\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;\n        return e.visitSafePropertyRead(this, t);\n      }\n    }]), t;\n  }(g),\n      S = function (e) {\n    function t(e, n, i) {\n      var r;\n      return a(this, t), (r = p(this, c(t).call(this, e))).obj = n, r.key = i, r;\n    }\n\n    return l(t, e), u(t, [{\n      key: \"visit\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;\n        return e.visitKeyedRead(this, t);\n      }\n    }]), t;\n  }(g),\n      N = function (e) {\n    function t(e, n, i, r) {\n      var s;\n      return a(this, t), (s = p(this, c(t).call(this, e))).obj = n, s.key = i, s.value = r, s;\n    }\n\n    return l(t, e), u(t, [{\n      key: \"visit\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;\n        return e.visitKeyedWrite(this, t);\n      }\n    }]), t;\n  }(g),\n      O = function (e) {\n    function t(e, n, i, r) {\n      var s;\n      return a(this, t), (s = p(this, c(t).call(this, e))).exp = n, s.name = i, s.args = r, s;\n    }\n\n    return l(t, e), u(t, [{\n      key: \"visit\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;\n        return e.visitPipe(this, t);\n      }\n    }]), t;\n  }(g),\n      I = function (e) {\n    function t(e, n) {\n      var i;\n      return a(this, t), (i = p(this, c(t).call(this, e))).value = n, i;\n    }\n\n    return l(t, e), u(t, [{\n      key: \"visit\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;\n        return e.visitLiteralPrimitive(this, t);\n      }\n    }]), t;\n  }(g),\n      _ = function (e) {\n    function t(e, n) {\n      var i;\n      return a(this, t), (i = p(this, c(t).call(this, e))).expressions = n, i;\n    }\n\n    return l(t, e), u(t, [{\n      key: \"visit\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;\n        return e.visitLiteralArray(this, t);\n      }\n    }]), t;\n  }(g),\n      L = function (e) {\n    function t(e, n, i) {\n      var r;\n      return a(this, t), (r = p(this, c(t).call(this, e))).keys = n, r.values = i, r;\n    }\n\n    return l(t, e), u(t, [{\n      key: \"visit\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;\n        return e.visitLiteralMap(this, t);\n      }\n    }]), t;\n  }(g),\n      M = function (e) {\n    function t(e, n, i) {\n      var r;\n      return a(this, t), (r = p(this, c(t).call(this, e))).strings = n, r.expressions = i, r;\n    }\n\n    return l(t, e), u(t, [{\n      key: \"visit\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;\n        return e.visitInterpolation(this, t);\n      }\n    }]), t;\n  }(g),\n      K = function (e) {\n    function t(e, n, i, r) {\n      var s;\n      return a(this, t), (s = p(this, c(t).call(this, e))).operation = n, s.left = i, s.right = r, s;\n    }\n\n    return l(t, e), u(t, [{\n      key: \"visit\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;\n        return e.visitBinary(this, t);\n      }\n    }]), t;\n  }(g),\n      B = function (e) {\n    function t(e, n) {\n      var i;\n      return a(this, t), (i = p(this, c(t).call(this, e))).expression = n, i;\n    }\n\n    return l(t, e), u(t, [{\n      key: \"visit\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;\n        return e.visitPrefixNot(this, t);\n      }\n    }]), t;\n  }(g),\n      T = function (e) {\n    function t(e, n) {\n      var i;\n      return a(this, t), (i = p(this, c(t).call(this, e))).expression = n, i;\n    }\n\n    return l(t, e), u(t, [{\n      key: \"visit\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;\n        return e.visitNonNullAssert(this, t);\n      }\n    }]), t;\n  }(g),\n      R = function (e) {\n    function t(e, n, i, r) {\n      var s;\n      return a(this, t), (s = p(this, c(t).call(this, e))).receiver = n, s.name = i, s.args = r, s;\n    }\n\n    return l(t, e), u(t, [{\n      key: \"visit\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;\n        return e.visitMethodCall(this, t);\n      }\n    }]), t;\n  }(g),\n      j = function (e) {\n    function t(e, n, i, r) {\n      var s;\n      return a(this, t), (s = p(this, c(t).call(this, e))).receiver = n, s.name = i, s.args = r, s;\n    }\n\n    return l(t, e), u(t, [{\n      key: \"visit\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;\n        return e.visitSafeMethodCall(this, t);\n      }\n    }]), t;\n  }(g),\n      F = function (e) {\n    function t(e, n, i) {\n      var r;\n      return a(this, t), (r = p(this, c(t).call(this, e))).target = n, r.args = i, r;\n    }\n\n    return l(t, e), u(t, [{\n      key: \"visit\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;\n        return e.visitFunctionCall(this, t);\n      }\n    }]), t;\n  }(g),\n      V = function e(t, n) {\n    a(this, e), this.start = t, this.end = n;\n  },\n      W = function (e) {\n    function t(e, n, i, r, s) {\n      var o;\n      return a(this, t), (o = p(this, c(t).call(this, new x(0, null == n ? 0 : n.length)))).ast = e, o.source = n, o.location = i, o.errors = s, o.sourceSpan = new V(r, r + o.span.end), o;\n    }\n\n    return l(t, e), u(t, [{\n      key: \"visit\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;\n        return e.visitASTWithSource ? e.visitASTWithSource(this, t) : this.ast.visit(e, t);\n      }\n    }, {\n      key: \"toString\",\n      value: function () {\n        return \"\".concat(this.source, \" in \").concat(this.location);\n      }\n    }]), t;\n  }(g),\n      G = function e(t, n, i, r, s) {\n    a(this, e), this.span = t, this.key = n, this.keyIsVar = i, this.name = r, this.expression = s;\n  },\n      U = function () {\n    function e() {\n      a(this, e);\n    }\n\n    return u(e, [{\n      key: \"visitBinary\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitChain\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitConditional\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitFunctionCall\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitImplicitReceiver\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitInterpolation\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitKeyedRead\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitKeyedWrite\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitLiteralArray\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitLiteralMap\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitLiteralPrimitive\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitMethodCall\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitPipe\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitPrefixNot\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitNonNullAssert\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitPropertyRead\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitPropertyWrite\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitQuote\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitSafeMethodCall\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitSafePropertyRead\",\n      value: function (e, t) {}\n    }]), e;\n  }(),\n      Q = function () {\n    function e() {\n      a(this, e);\n    }\n\n    return u(e, [{\n      key: \"visitBinary\",\n      value: function (e, t) {\n        return e.left.visit(this, t), e.right.visit(this, t), null;\n      }\n    }, {\n      key: \"visitChain\",\n      value: function (e, t) {\n        return this.visitAll(e.expressions, t);\n      }\n    }, {\n      key: \"visitConditional\",\n      value: function (e, t) {\n        return e.condition.visit(this, t), e.trueExp.visit(this, t), e.falseExp.visit(this, t), null;\n      }\n    }, {\n      key: \"visitPipe\",\n      value: function (e, t) {\n        return e.exp.visit(this, t), this.visitAll(e.args, t), null;\n      }\n    }, {\n      key: \"visitFunctionCall\",\n      value: function (e, t) {\n        return e.target.visit(this, t), this.visitAll(e.args, t), null;\n      }\n    }, {\n      key: \"visitImplicitReceiver\",\n      value: function (e, t) {\n        return null;\n      }\n    }, {\n      key: \"visitInterpolation\",\n      value: function (e, t) {\n        return this.visitAll(e.expressions, t);\n      }\n    }, {\n      key: \"visitKeyedRead\",\n      value: function (e, t) {\n        return e.obj.visit(this, t), e.key.visit(this, t), null;\n      }\n    }, {\n      key: \"visitKeyedWrite\",\n      value: function (e, t) {\n        return e.obj.visit(this, t), e.key.visit(this, t), e.value.visit(this, t), null;\n      }\n    }, {\n      key: \"visitLiteralArray\",\n      value: function (e, t) {\n        return this.visitAll(e.expressions, t);\n      }\n    }, {\n      key: \"visitLiteralMap\",\n      value: function (e, t) {\n        return this.visitAll(e.values, t);\n      }\n    }, {\n      key: \"visitLiteralPrimitive\",\n      value: function (e, t) {\n        return null;\n      }\n    }, {\n      key: \"visitMethodCall\",\n      value: function (e, t) {\n        return e.receiver.visit(this, t), this.visitAll(e.args, t);\n      }\n    }, {\n      key: \"visitPrefixNot\",\n      value: function (e, t) {\n        return e.expression.visit(this, t), null;\n      }\n    }, {\n      key: \"visitNonNullAssert\",\n      value: function (e, t) {\n        return e.expression.visit(this, t), null;\n      }\n    }, {\n      key: \"visitPropertyRead\",\n      value: function (e, t) {\n        return e.receiver.visit(this, t), null;\n      }\n    }, {\n      key: \"visitPropertyWrite\",\n      value: function (e, t) {\n        return e.receiver.visit(this, t), e.value.visit(this, t), null;\n      }\n    }, {\n      key: \"visitSafePropertyRead\",\n      value: function (e, t) {\n        return e.receiver.visit(this, t), null;\n      }\n    }, {\n      key: \"visitSafeMethodCall\",\n      value: function (e, t) {\n        return e.receiver.visit(this, t), this.visitAll(e.args, t);\n      }\n    }, {\n      key: \"visitAll\",\n      value: function (e, t) {\n        var n = this;\n        return e.forEach(function (e) {\n          return e.visit(n, t);\n        }), null;\n      }\n    }, {\n      key: \"visitQuote\",\n      value: function (e, t) {\n        return null;\n      }\n    }]), e;\n  }(),\n      z = function () {\n    function e() {\n      a(this, e);\n    }\n\n    return u(e, [{\n      key: \"visitImplicitReceiver\",\n      value: function (e, t) {\n        return e;\n      }\n    }, {\n      key: \"visitInterpolation\",\n      value: function (e, t) {\n        return new M(e.span, e.strings, this.visitAll(e.expressions));\n      }\n    }, {\n      key: \"visitLiteralPrimitive\",\n      value: function (e, t) {\n        return new I(e.span, e.value);\n      }\n    }, {\n      key: \"visitPropertyRead\",\n      value: function (e, t) {\n        return new b(e.span, e.receiver.visit(this), e.name);\n      }\n    }, {\n      key: \"visitPropertyWrite\",\n      value: function (e, t) {\n        return new A(e.span, e.receiver.visit(this), e.name, e.value.visit(this));\n      }\n    }, {\n      key: \"visitSafePropertyRead\",\n      value: function (e, t) {\n        return new E(e.span, e.receiver.visit(this), e.name);\n      }\n    }, {\n      key: \"visitMethodCall\",\n      value: function (e, t) {\n        return new R(e.span, e.receiver.visit(this), e.name, this.visitAll(e.args));\n      }\n    }, {\n      key: \"visitSafeMethodCall\",\n      value: function (e, t) {\n        return new j(e.span, e.receiver.visit(this), e.name, this.visitAll(e.args));\n      }\n    }, {\n      key: \"visitFunctionCall\",\n      value: function (e, t) {\n        return new F(e.span, e.target.visit(this), this.visitAll(e.args));\n      }\n    }, {\n      key: \"visitLiteralArray\",\n      value: function (e, t) {\n        return new _(e.span, this.visitAll(e.expressions));\n      }\n    }, {\n      key: \"visitLiteralMap\",\n      value: function (e, t) {\n        return new L(e.span, e.keys, this.visitAll(e.values));\n      }\n    }, {\n      key: \"visitBinary\",\n      value: function (e, t) {\n        return new K(e.span, e.operation, e.left.visit(this), e.right.visit(this));\n      }\n    }, {\n      key: \"visitPrefixNot\",\n      value: function (e, t) {\n        return new B(e.span, e.expression.visit(this));\n      }\n    }, {\n      key: \"visitNonNullAssert\",\n      value: function (e, t) {\n        return new T(e.span, e.expression.visit(this));\n      }\n    }, {\n      key: \"visitConditional\",\n      value: function (e, t) {\n        return new P(e.span, e.condition.visit(this), e.trueExp.visit(this), e.falseExp.visit(this));\n      }\n    }, {\n      key: \"visitPipe\",\n      value: function (e, t) {\n        return new O(e.span, e.exp.visit(this), e.name, this.visitAll(e.args));\n      }\n    }, {\n      key: \"visitKeyedRead\",\n      value: function (e, t) {\n        return new S(e.span, e.obj.visit(this), e.key.visit(this));\n      }\n    }, {\n      key: \"visitKeyedWrite\",\n      value: function (e, t) {\n        return new N(e.span, e.obj.visit(this), e.key.visit(this), e.value.visit(this));\n      }\n    }, {\n      key: \"visitAll\",\n      value: function (e) {\n        for (var t = new Array(e.length), n = 0; n < e.length; ++n) t[n] = e[n].visit(this);\n\n        return t;\n      }\n    }, {\n      key: \"visitChain\",\n      value: function (e, t) {\n        return new C(e.span, this.visitAll(e.expressions));\n      }\n    }, {\n      key: \"visitQuote\",\n      value: function (e, t) {\n        return new k(e.span, e.prefix, e.uninterpretedExpression, e.location);\n      }\n    }]), e;\n  }(),\n      $ = function () {\n    function e() {\n      a(this, e);\n    }\n\n    return u(e, [{\n      key: \"visitImplicitReceiver\",\n      value: function (e, t) {\n        return e;\n      }\n    }, {\n      key: \"visitInterpolation\",\n      value: function (e, t) {\n        var n = this.visitAll(e.expressions);\n        return n !== e.expressions ? new M(e.span, e.strings, n) : e;\n      }\n    }, {\n      key: \"visitLiteralPrimitive\",\n      value: function (e, t) {\n        return e;\n      }\n    }, {\n      key: \"visitPropertyRead\",\n      value: function (e, t) {\n        var n = e.receiver.visit(this);\n        return n !== e.receiver ? new b(e.span, n, e.name) : e;\n      }\n    }, {\n      key: \"visitPropertyWrite\",\n      value: function (e, t) {\n        var n = e.receiver.visit(this),\n            i = e.value.visit(this);\n        return n !== e.receiver || i !== e.value ? new A(e.span, n, e.name, i) : e;\n      }\n    }, {\n      key: \"visitSafePropertyRead\",\n      value: function (e, t) {\n        var n = e.receiver.visit(this);\n        return n !== e.receiver ? new E(e.span, n, e.name) : e;\n      }\n    }, {\n      key: \"visitMethodCall\",\n      value: function (e, t) {\n        var n = e.receiver.visit(this),\n            i = this.visitAll(e.args);\n        return n !== e.receiver || i !== e.args ? new R(e.span, n, e.name, i) : e;\n      }\n    }, {\n      key: \"visitSafeMethodCall\",\n      value: function (e, t) {\n        var n = e.receiver.visit(this),\n            i = this.visitAll(e.args);\n        return n !== e.receiver || i !== e.args ? new j(e.span, n, e.name, i) : e;\n      }\n    }, {\n      key: \"visitFunctionCall\",\n      value: function (e, t) {\n        var n = e.target && e.target.visit(this),\n            i = this.visitAll(e.args);\n        return n !== e.target || i !== e.args ? new F(e.span, n, i) : e;\n      }\n    }, {\n      key: \"visitLiteralArray\",\n      value: function (e, t) {\n        var n = this.visitAll(e.expressions);\n        return n !== e.expressions ? new _(e.span, n) : e;\n      }\n    }, {\n      key: \"visitLiteralMap\",\n      value: function (e, t) {\n        var n = this.visitAll(e.values);\n        return n !== e.values ? new L(e.span, e.keys, n) : e;\n      }\n    }, {\n      key: \"visitBinary\",\n      value: function (e, t) {\n        var n = e.left.visit(this),\n            i = e.right.visit(this);\n        return n !== e.left || i !== e.right ? new K(e.span, e.operation, n, i) : e;\n      }\n    }, {\n      key: \"visitPrefixNot\",\n      value: function (e, t) {\n        var n = e.expression.visit(this);\n        return n !== e.expression ? new B(e.span, n) : e;\n      }\n    }, {\n      key: \"visitNonNullAssert\",\n      value: function (e, t) {\n        var n = e.expression.visit(this);\n        return n !== e.expression ? new T(e.span, n) : e;\n      }\n    }, {\n      key: \"visitConditional\",\n      value: function (e, t) {\n        var n = e.condition.visit(this),\n            i = e.trueExp.visit(this),\n            r = e.falseExp.visit(this);\n        return n !== e.condition || i !== e.trueExp || r !== e.falseExp ? new P(e.span, n, i, r) : e;\n      }\n    }, {\n      key: \"visitPipe\",\n      value: function (e, t) {\n        var n = e.exp.visit(this),\n            i = this.visitAll(e.args);\n        return n !== e.exp || i !== e.args ? new O(e.span, n, e.name, i) : e;\n      }\n    }, {\n      key: \"visitKeyedRead\",\n      value: function (e, t) {\n        var n = e.obj.visit(this),\n            i = e.key.visit(this);\n        return n !== e.obj || i !== e.key ? new S(e.span, n, i) : e;\n      }\n    }, {\n      key: \"visitKeyedWrite\",\n      value: function (e, t) {\n        var n = e.obj.visit(this),\n            i = e.key.visit(this),\n            r = e.value.visit(this);\n        return n !== e.obj || i !== e.key || r !== e.value ? new N(e.span, n, i, r) : e;\n      }\n    }, {\n      key: \"visitAll\",\n      value: function (e) {\n        for (var t = new Array(e.length), n = !1, i = 0; i < e.length; ++i) {\n          var r = e[i],\n              s = r.visit(this);\n          t[i] = s, n = n || s !== r;\n        }\n\n        return n ? t : e;\n      }\n    }, {\n      key: \"visitChain\",\n      value: function (e, t) {\n        var n = this.visitAll(e.expressions);\n        return n !== e.expressions ? new C(e.span, n) : e;\n      }\n    }, {\n      key: \"visitQuote\",\n      value: function (e, t) {\n        return e;\n      }\n    }]), e;\n  }();\n\n  var q;\n  !function (e) {\n    e[e.DEFAULT = 0] = \"DEFAULT\", e[e.LITERAL_ATTR = 1] = \"LITERAL_ATTR\", e[e.ANIMATION = 2] = \"ANIMATION\";\n  }(q || (q = {}));\n  var D,\n      H = Object.freeze({\n    __proto__: null,\n    ParserError: y,\n    ParseSpan: x,\n    AST: g,\n    Quote: k,\n    EmptyExpr: m,\n    ImplicitReceiver: w,\n    Chain: C,\n    Conditional: P,\n    PropertyRead: b,\n    PropertyWrite: A,\n    SafePropertyRead: E,\n    KeyedRead: S,\n    KeyedWrite: N,\n    BindingPipe: O,\n    LiteralPrimitive: I,\n    LiteralArray: _,\n    LiteralMap: L,\n    Interpolation: M,\n    Binary: K,\n    PrefixNot: B,\n    NonNullAssert: T,\n    MethodCall: R,\n    SafeMethodCall: j,\n    FunctionCall: F,\n    AbsoluteSourceSpan: V,\n    ASTWithSource: W,\n    TemplateBinding: G,\n    NullAstVisitor: U,\n    RecursiveAstVisitor: Q,\n    AstTransformer: z,\n    AstMemoryEfficientTransformer: $,\n    visitAstChildren: function (e, t, n) {\n      function i(e) {\n        t.visit && t.visit(e, n) || e.visit(t, n);\n      }\n\n      function r(e) {\n        e.forEach(i);\n      }\n\n      e.visit({\n        visitBinary: function (e) {\n          i(e.left), i(e.right);\n        },\n        visitChain: function (e) {\n          r(e.expressions);\n        },\n        visitConditional: function (e) {\n          i(e.condition), i(e.trueExp), i(e.falseExp);\n        },\n        visitFunctionCall: function (e) {\n          e.target && i(e.target), r(e.args);\n        },\n        visitImplicitReceiver: function (e) {},\n        visitInterpolation: function (e) {\n          r(e.expressions);\n        },\n        visitKeyedRead: function (e) {\n          i(e.obj), i(e.key);\n        },\n        visitKeyedWrite: function (e) {\n          i(e.obj), i(e.key), i(e.obj);\n        },\n        visitLiteralArray: function (e) {\n          r(e.expressions);\n        },\n        visitLiteralMap: function (e) {},\n        visitLiteralPrimitive: function (e) {},\n        visitMethodCall: function (e) {\n          i(e.receiver), r(e.args);\n        },\n        visitPipe: function (e) {\n          i(e.exp), r(e.args);\n        },\n        visitPrefixNot: function (e) {\n          i(e.expression);\n        },\n        visitNonNullAssert: function (e) {\n          i(e.expression);\n        },\n        visitPropertyRead: function (e) {\n          i(e.receiver);\n        },\n        visitPropertyWrite: function (e) {\n          i(e.receiver), i(e.value);\n        },\n        visitQuote: function (e) {},\n        visitSafeMethodCall: function (e) {\n          i(e.receiver), r(e.args);\n        },\n        visitSafePropertyRead: function (e) {\n          i(e.receiver);\n        }\n      });\n    },\n    ParsedProperty: function e(t, n, i, r, s) {\n      a(this, e), this.name = t, this.expression = n, this.type = i, this.sourceSpan = r, this.valueSpan = s, this.isLiteral = this.type === q.LITERAL_ATTR, this.isAnimation = this.type === q.ANIMATION;\n    },\n\n    get ParsedPropertyType() {\n      return q;\n    },\n\n    ParsedEvent: function e(t, n, i, r, s, o) {\n      a(this, e), this.name = t, this.targetOrPhase = n, this.type = i, this.handler = r, this.sourceSpan = s, this.handlerSpan = o;\n    },\n    ParsedVariable: function e(t, n, i) {\n      a(this, e), this.name = t, this.value = n, this.sourceSpan = i;\n    },\n    BoundElementProperty: function e(t, n, i, r, s, o, u) {\n      a(this, e), this.name = t, this.type = n, this.securityContext = i, this.value = r, this.unit = s, this.sourceSpan = o, this.valueSpan = u;\n    }\n  }),\n      J = 0,\n      X = 9,\n      Y = 10,\n      Z = 11,\n      ee = 12,\n      te = 13,\n      ne = 32,\n      ie = 34,\n      re = 36,\n      se = 39,\n      ae = 43,\n      oe = 45,\n      ue = 48,\n      le = 57,\n      ce = 65,\n      he = 69,\n      pe = 90,\n      ve = 95,\n      fe = 97,\n      de = 101,\n      ye = 102,\n      xe = 110,\n      ge = 114,\n      ke = 116,\n      me = 118,\n      we = 122,\n      Ce = 160,\n      Pe = 96;\n\n  function be(e) {\n    return ue <= e && e <= le;\n  }\n\n  !function (e) {\n    e[e.Character = 0] = \"Character\", e[e.Identifier = 1] = \"Identifier\", e[e.Keyword = 2] = \"Keyword\", e[e.String = 3] = \"String\", e[e.Operator = 4] = \"Operator\", e[e.Number = 5] = \"Number\", e[e.Error = 6] = \"Error\";\n  }(D || (D = {}));\n\n  var Ae = [\"var\", \"let\", \"as\", \"null\", \"undefined\", \"true\", \"false\", \"if\", \"else\", \"this\"],\n      Ee = function () {\n    function e() {\n      a(this, e);\n    }\n\n    return u(e, [{\n      key: \"tokenize\",\n      value: function (e) {\n        for (var t = new _e(e), n = [], i = t.scanToken(); null != i;) n.push(i), i = t.scanToken();\n\n        return n;\n      }\n    }]), e;\n  }(),\n      Se = function () {\n    function e(t, n, i, r) {\n      a(this, e), this.index = t, this.type = n, this.numValue = i, this.strValue = r;\n    }\n\n    return u(e, [{\n      key: \"isCharacter\",\n      value: function (e) {\n        return this.type == D.Character && this.numValue == e;\n      }\n    }, {\n      key: \"isNumber\",\n      value: function () {\n        return this.type == D.Number;\n      }\n    }, {\n      key: \"isString\",\n      value: function () {\n        return this.type == D.String;\n      }\n    }, {\n      key: \"isOperator\",\n      value: function (e) {\n        return this.type == D.Operator && this.strValue == e;\n      }\n    }, {\n      key: \"isIdentifier\",\n      value: function () {\n        return this.type == D.Identifier;\n      }\n    }, {\n      key: \"isKeyword\",\n      value: function () {\n        return this.type == D.Keyword;\n      }\n    }, {\n      key: \"isKeywordLet\",\n      value: function () {\n        return this.type == D.Keyword && \"let\" == this.strValue;\n      }\n    }, {\n      key: \"isKeywordAs\",\n      value: function () {\n        return this.type == D.Keyword && \"as\" == this.strValue;\n      }\n    }, {\n      key: \"isKeywordNull\",\n      value: function () {\n        return this.type == D.Keyword && \"null\" == this.strValue;\n      }\n    }, {\n      key: \"isKeywordUndefined\",\n      value: function () {\n        return this.type == D.Keyword && \"undefined\" == this.strValue;\n      }\n    }, {\n      key: \"isKeywordTrue\",\n      value: function () {\n        return this.type == D.Keyword && \"true\" == this.strValue;\n      }\n    }, {\n      key: \"isKeywordFalse\",\n      value: function () {\n        return this.type == D.Keyword && \"false\" == this.strValue;\n      }\n    }, {\n      key: \"isKeywordThis\",\n      value: function () {\n        return this.type == D.Keyword && \"this\" == this.strValue;\n      }\n    }, {\n      key: \"isError\",\n      value: function () {\n        return this.type == D.Error;\n      }\n    }, {\n      key: \"toNumber\",\n      value: function () {\n        return this.type == D.Number ? this.numValue : -1;\n      }\n    }, {\n      key: \"toString\",\n      value: function () {\n        switch (this.type) {\n          case D.Character:\n          case D.Identifier:\n          case D.Keyword:\n          case D.Operator:\n          case D.String:\n          case D.Error:\n            return this.strValue;\n\n          case D.Number:\n            return this.numValue.toString();\n\n          default:\n            return null;\n        }\n      }\n    }]), e;\n  }();\n\n  function Ne(e, t) {\n    return new Se(e, D.Character, t, String.fromCharCode(t));\n  }\n\n  function Oe(e, t) {\n    return new Se(e, D.Operator, 0, t);\n  }\n\n  var Ie = new Se(-1, D.Character, 0, \"\"),\n      _e = function () {\n    function e(t) {\n      a(this, e), this.input = t, this.peek = 0, this.index = -1, this.length = t.length, this.advance();\n    }\n\n    return u(e, [{\n      key: \"advance\",\n      value: function () {\n        this.peek = ++this.index >= this.length ? J : this.input.charCodeAt(this.index);\n      }\n    }, {\n      key: \"scanToken\",\n      value: function () {\n        for (var e = this.input, t = this.length, n = this.peek, i = this.index; n <= ne;) {\n          if (++i >= t) {\n            n = J;\n            break;\n          }\n\n          n = e.charCodeAt(i);\n        }\n\n        if (this.peek = n, this.index = i, i >= t) return null;\n        if (Le(n)) return this.scanIdentifier();\n        if (be(n)) return this.scanNumber(i);\n        var r,\n            s = i;\n\n        switch (n) {\n          case 46:\n            return this.advance(), be(this.peek) ? this.scanNumber(s) : Ne(s, 46);\n\n          case 40:\n          case 41:\n          case 123:\n          case 125:\n          case 91:\n          case 93:\n          case 44:\n          case 58:\n          case 59:\n            return this.scanCharacter(s, n);\n\n          case se:\n          case ie:\n            return this.scanString();\n\n          case 35:\n          case ae:\n          case oe:\n          case 42:\n          case 47:\n          case 37:\n          case 94:\n            return this.scanOperator(s, String.fromCharCode(n));\n\n          case 63:\n            return this.scanComplexOperator(s, \"?\", 46, \".\");\n\n          case 60:\n          case 62:\n            return this.scanComplexOperator(s, String.fromCharCode(n), 61, \"=\");\n\n          case 33:\n          case 61:\n            return this.scanComplexOperator(s, String.fromCharCode(n), 61, \"=\", 61, \"=\");\n\n          case 38:\n            return this.scanComplexOperator(s, \"&\", 38, \"&\");\n\n          case 124:\n            return this.scanComplexOperator(s, \"|\", 124, \"|\");\n\n          case Ce:\n            for (; (r = this.peek) >= X && r <= ne || r == Ce;) this.advance();\n\n            return this.scanToken();\n        }\n\n        return this.advance(), this.error(\"Unexpected character [\".concat(String.fromCharCode(n), \"]\"), 0);\n      }\n    }, {\n      key: \"scanCharacter\",\n      value: function (e, t) {\n        return this.advance(), Ne(e, t);\n      }\n    }, {\n      key: \"scanOperator\",\n      value: function (e, t) {\n        return this.advance(), Oe(e, t);\n      }\n    }, {\n      key: \"scanComplexOperator\",\n      value: function (e, t, n, i, r, s) {\n        this.advance();\n        var a = t;\n        return this.peek == n && (this.advance(), a += i), null != r && this.peek == r && (this.advance(), a += s), Oe(e, a);\n      }\n    }, {\n      key: \"scanIdentifier\",\n      value: function () {\n        var e = this.index;\n\n        for (this.advance(); Ke(this.peek);) this.advance();\n\n        var t,\n            n = this.input.substring(e, this.index);\n        return Ae.indexOf(n) > -1 ? (t = n, new Se(e, D.Keyword, 0, t)) : function (e, t) {\n          return new Se(e, D.Identifier, 0, t);\n        }(e, n);\n      }\n    }, {\n      key: \"scanNumber\",\n      value: function (e) {\n        var t,\n            n = this.index === e;\n\n        for (this.advance();;) {\n          if (be(this.peek)) ;else if (46 == this.peek) n = !1;else {\n            if ((t = this.peek) != de && t != he) break;\n            if (this.advance(), Be(this.peek) && this.advance(), !be(this.peek)) return this.error(\"Invalid exponent\", -1);\n            n = !1;\n          }\n          this.advance();\n        }\n\n        var i,\n            r = this.input.substring(e, this.index),\n            s = n ? function (e) {\n          var t = parseInt(e);\n          if (isNaN(t)) throw new Error(\"Invalid integer literal when parsing \" + e);\n          return t;\n        }(r) : parseFloat(r);\n        return i = s, new Se(e, D.Number, i, \"\");\n      }\n    }, {\n      key: \"scanString\",\n      value: function () {\n        var e = this.index,\n            t = this.peek;\n        this.advance();\n\n        for (var n = \"\", i = this.index, r = this.input; this.peek != t;) if (92 == this.peek) {\n          n += r.substring(i, this.index), this.advance();\n          var s = void 0;\n\n          if (this.peek = this.peek, 117 == this.peek) {\n            var a = r.substring(this.index + 1, this.index + 5);\n            if (!/^[0-9a-f]+$/i.test(a)) return this.error(\"Invalid unicode escape [\\\\u\".concat(a, \"]\"), 0);\n            s = parseInt(a, 16);\n\n            for (var o = 0; o < 5; o++) this.advance();\n          } else s = Re(this.peek), this.advance();\n\n          n += String.fromCharCode(s), i = this.index;\n        } else {\n          if (this.peek == J) return this.error(\"Unterminated quote\", 0);\n          this.advance();\n        }\n\n        var u,\n            l = r.substring(i, this.index);\n        return this.advance(), u = n + l, new Se(e, D.String, 0, u);\n      }\n    }, {\n      key: \"error\",\n      value: function (e, t) {\n        var n = this.index + t;\n        return function (e, t) {\n          return new Se(e, D.Error, 0, t);\n        }(n, \"Lexer Error: \".concat(e, \" at column \").concat(n, \" in expression [\").concat(this.input, \"]\"));\n      }\n    }]), e;\n  }();\n\n  function Le(e) {\n    return fe <= e && e <= we || ce <= e && e <= pe || e == ve || e == re;\n  }\n\n  function Me(e) {\n    if (0 == e.length) return !1;\n    var t = new _e(e);\n    if (!Le(t.peek)) return !1;\n\n    for (t.advance(); t.peek !== J;) {\n      if (!Ke(t.peek)) return !1;\n      t.advance();\n    }\n\n    return !0;\n  }\n\n  function Ke(e) {\n    return function (e) {\n      return e >= fe && e <= we || e >= ce && e <= pe;\n    }(e) || be(e) || e == ve || e == re;\n  }\n\n  function Be(e) {\n    return e == oe || e == ae;\n  }\n\n  function Te(e) {\n    return e === se || e === ie || e === Pe;\n  }\n\n  function Re(e) {\n    switch (e) {\n      case xe:\n        return Y;\n\n      case ye:\n        return ee;\n\n      case ge:\n        return te;\n\n      case ke:\n        return X;\n\n      case me:\n        return Z;\n\n      default:\n        return e;\n    }\n  }\n\n  var je = Object.freeze({\n    __proto__: null,\n\n    get TokenType() {\n      return D;\n    },\n\n    Lexer: Ee,\n    Token: Se,\n    EOF: Ie,\n    isIdentifier: Me,\n    isQuote: Te\n  }),\n      Fe = [/^\\s*$/, /[<>]/, /^[{}]$/, /&(#|[a-z])/i, /^\\/\\//];\n  /**\n     * @license\n     * Copyright Google Inc. All Rights Reserved.\n     *\n     * Use of this source code is governed by an MIT-style license that can be\n     * found in the LICENSE file at https://angular.io/license\n     */\n\n  var Ve = new (function () {\n    function e(t, n) {\n      a(this, e), this.start = t, this.end = n;\n    }\n\n    return u(e, null, [{\n      key: \"fromArray\",\n      value: function (t) {\n        return t ? (function (e, t) {\n          if (!(null == t || Array.isArray(t) && 2 == t.length)) throw new Error(\"Expected '\".concat(e, \"' to be an array, [start, end].\"));\n\n          if (null != t) {\n            var n = t[0],\n                i = t[1];\n            Fe.forEach(function (e) {\n              if (e.test(n) || e.test(i)) throw new Error(\"['\".concat(n, \"', '\").concat(i, \"'] contains unusable interpolation symbol.\"));\n            });\n          }\n        }(\"interpolation\", t), new e(t[0], t[1])) : Ve;\n      }\n    }]), e;\n  }())(\"{{\", \"}}\");\n\n  function We(e) {\n    return e.replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, \"\\\\$1\");\n  }\n\n  \"undefined\" != typeof self && \"undefined\" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && self;\n\n  var Ge = function e(t, n, i) {\n    a(this, e), this.strings = t, this.expressions = n, this.offsets = i;\n  },\n      Ue = function e(t, n, i) {\n    a(this, e), this.templateBindings = t, this.warnings = n, this.errors = i;\n  };\n\n  function Qe(e) {\n    var t = We(e.start) + \"([\\\\s\\\\S]*?)\" + We(e.end);\n    return new RegExp(t, \"g\");\n  }\n\n  var ze = function () {\n    function e(t) {\n      a(this, e), this._lexer = t, this.errors = [];\n    }\n\n    return u(e, [{\n      key: \"parseAction\",\n      value: function (e, t, n) {\n        var i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Ve;\n\n        this._checkNoInterpolation(e, t, i);\n\n        var r = this._stripComments(e),\n            s = this._lexer.tokenize(this._stripComments(e)),\n            a = new $e(e, t, n, s, r.length, !0, this.errors, e.length - r.length).parseChain();\n\n        return new W(a, e, t, n, this.errors);\n      }\n    }, {\n      key: \"parseBinding\",\n      value: function (e, t, n) {\n        var i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Ve,\n            r = this._parseBindingAst(e, t, n, i);\n\n        return new W(r, e, t, n, this.errors);\n      }\n    }, {\n      key: \"parseSimpleBinding\",\n      value: function (e, t, n) {\n        var i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Ve,\n            r = this._parseBindingAst(e, t, n, i),\n            s = qe.check(r);\n\n        return s.length > 0 && this._reportError(\"Host binding expression cannot contain \".concat(s.join(\" \")), e, t), new W(r, e, t, n, this.errors);\n      }\n    }, {\n      key: \"_reportError\",\n      value: function (e, t, n, i) {\n        this.errors.push(new y(e, t, n, i));\n      }\n    }, {\n      key: \"_parseBindingAst\",\n      value: function (e, t, n, i) {\n        var r = this._parseQuote(e, t);\n\n        if (null != r) return r;\n\n        this._checkNoInterpolation(e, t, i);\n\n        var s = this._stripComments(e),\n            a = this._lexer.tokenize(s);\n\n        return new $e(e, t, n, a, s.length, !1, this.errors, e.length - s.length).parseChain();\n      }\n    }, {\n      key: \"_parseQuote\",\n      value: function (e, t) {\n        if (null == e) return null;\n        var n = e.indexOf(\":\");\n        if (-1 == n) return null;\n        var i = e.substring(0, n).trim();\n        if (!Me(i)) return null;\n        var r = e.substring(n + 1);\n        return new k(new x(0, e.length), i, r, t);\n      }\n    }, {\n      key: \"parseTemplateBindings\",\n      value: function (e, t, n, i) {\n        var r = this._lexer.tokenize(t);\n\n        return new $e(t, n, i, r, t.length, !1, this.errors, 0).parseTemplateBindings(e);\n      }\n    }, {\n      key: \"parseInterpolation\",\n      value: function (e, t, n) {\n        var i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : Ve,\n            r = this.splitInterpolation(e, t, i);\n        if (null == r) return null;\n\n        for (var s = [], a = 0; a < r.expressions.length; ++a) {\n          var o = r.expressions[a],\n              u = this._stripComments(o),\n              l = this._lexer.tokenize(u),\n              c = new $e(e, t, n, l, u.length, !1, this.errors, r.offsets[a] + (o.length - u.length)).parseChain();\n\n          s.push(c);\n        }\n\n        return new W(new M(new x(0, null == e ? 0 : e.length), r.strings, s), e, t, n, this.errors);\n      }\n    }, {\n      key: \"splitInterpolation\",\n      value: function (e, t) {\n        var n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : Ve,\n            i = Qe(n),\n            r = e.split(i);\n        if (r.length <= 1) return null;\n\n        for (var s = [], a = [], o = [], u = 0, l = 0; l < r.length; l++) {\n          var c = r[l];\n          l % 2 == 0 ? (s.push(c), u += c.length) : c.trim().length > 0 ? (u += n.start.length, a.push(c), o.push(u), u += c.length + n.end.length) : (this._reportError(\"Blank expressions are not allowed in interpolated strings\", e, \"at column \".concat(this._findInterpolationErrorColumn(r, l, n), \" in\"), t), a.push(\"$implict\"), o.push(u));\n        }\n\n        return new Ge(s, a, o);\n      }\n    }, {\n      key: \"wrapLiteralPrimitive\",\n      value: function (e, t, n) {\n        return new W(new I(new x(0, null == e ? 0 : e.length), e), e, t, n, this.errors);\n      }\n    }, {\n      key: \"_stripComments\",\n      value: function (e) {\n        var t = this._commentStart(e);\n\n        return null != t ? e.substring(0, t).trim() : e;\n      }\n    }, {\n      key: \"_commentStart\",\n      value: function (e) {\n        for (var t = null, n = 0; n < e.length - 1; n++) {\n          var i = e.charCodeAt(n),\n              r = e.charCodeAt(n + 1);\n          if (47 === i && 47 == r && null == t) return n;\n          t === i ? t = null : null == t && Te(i) && (t = i);\n        }\n\n        return null;\n      }\n    }, {\n      key: \"_checkNoInterpolation\",\n      value: function (e, t, n) {\n        var i = Qe(n),\n            r = e.split(i);\n        r.length > 1 && this._reportError(\"Got interpolation (\".concat(n.start).concat(n.end, \") where expression was expected\"), e, \"at column \".concat(this._findInterpolationErrorColumn(r, 1, n), \" in\"), t);\n      }\n    }, {\n      key: \"_findInterpolationErrorColumn\",\n      value: function (e, t, n) {\n        for (var i = \"\", r = 0; r < t; r++) i += r % 2 == 0 ? e[r] : \"\".concat(n.start).concat(e[r]).concat(n.end);\n\n        return i.length;\n      }\n    }]), e;\n  }(),\n      $e = function () {\n    function e(t, n, i, r, s, o, u, l) {\n      a(this, e), this.input = t, this.location = n, this.absoluteOffset = i, this.tokens = r, this.inputLength = s, this.parseAction = o, this.errors = u, this.offset = l, this.rparensExpected = 0, this.rbracketsExpected = 0, this.rbracesExpected = 0, this.index = 0;\n    }\n\n    return u(e, [{\n      key: \"peek\",\n      value: function (e) {\n        var t = this.index + e;\n        return t < this.tokens.length ? this.tokens[t] : Ie;\n      }\n    }, {\n      key: \"span\",\n      value: function (e) {\n        return new x(e, this.inputIndex);\n      }\n    }, {\n      key: \"advance\",\n      value: function () {\n        this.index++;\n      }\n    }, {\n      key: \"optionalCharacter\",\n      value: function (e) {\n        return !!this.next.isCharacter(e) && (this.advance(), !0);\n      }\n    }, {\n      key: \"peekKeywordLet\",\n      value: function () {\n        return this.next.isKeywordLet();\n      }\n    }, {\n      key: \"peekKeywordAs\",\n      value: function () {\n        return this.next.isKeywordAs();\n      }\n    }, {\n      key: \"expectCharacter\",\n      value: function (e) {\n        this.optionalCharacter(e) || this.error(\"Missing expected \".concat(String.fromCharCode(e)));\n      }\n    }, {\n      key: \"optionalOperator\",\n      value: function (e) {\n        return !!this.next.isOperator(e) && (this.advance(), !0);\n      }\n    }, {\n      key: \"expectOperator\",\n      value: function (e) {\n        this.optionalOperator(e) || this.error(\"Missing expected operator \".concat(e));\n      }\n    }, {\n      key: \"expectIdentifierOrKeyword\",\n      value: function () {\n        var e = this.next;\n        return e.isIdentifier() || e.isKeyword() ? (this.advance(), e.toString()) : (this.error(\"Unexpected token \".concat(e, \", expected identifier or keyword\")), \"\");\n      }\n    }, {\n      key: \"expectIdentifierOrKeywordOrString\",\n      value: function () {\n        var e = this.next;\n        return e.isIdentifier() || e.isKeyword() || e.isString() ? (this.advance(), e.toString()) : (this.error(\"Unexpected token \".concat(e, \", expected identifier, keyword, or string\")), \"\");\n      }\n    }, {\n      key: \"parseChain\",\n      value: function () {\n        for (var e = [], t = this.inputIndex; this.index < this.tokens.length;) {\n          var n = this.parsePipe();\n          if (e.push(n), this.optionalCharacter(59)) for (this.parseAction || this.error(\"Binding expression cannot contain chained expression\"); this.optionalCharacter(59););else this.index < this.tokens.length && this.error(\"Unexpected token '\".concat(this.next, \"'\"));\n        }\n\n        return 0 == e.length ? new m(this.span(t)) : 1 == e.length ? e[0] : new C(this.span(t), e);\n      }\n    }, {\n      key: \"parsePipe\",\n      value: function () {\n        var e = this.parseExpression();\n\n        if (this.optionalOperator(\"|\")) {\n          this.parseAction && this.error(\"Cannot have a pipe in an action expression\");\n\n          do {\n            for (var t = this.expectIdentifierOrKeyword(), n = []; this.optionalCharacter(58);) n.push(this.parseExpression());\n\n            e = new O(this.span(e.span.start), e, t, n);\n          } while (this.optionalOperator(\"|\"));\n        }\n\n        return e;\n      }\n    }, {\n      key: \"parseExpression\",\n      value: function () {\n        return this.parseConditional();\n      }\n    }, {\n      key: \"parseConditional\",\n      value: function () {\n        var e = this.inputIndex,\n            t = this.parseLogicalOr();\n\n        if (this.optionalOperator(\"?\")) {\n          var n,\n              i = this.parsePipe();\n          if (this.optionalCharacter(58)) n = this.parsePipe();else {\n            var r = this.inputIndex,\n                s = this.input.substring(e, r);\n            this.error(\"Conditional expression \".concat(s, \" requires all 3 expressions\")), n = new m(this.span(e));\n          }\n          return new P(this.span(e), t, i, n);\n        }\n\n        return t;\n      }\n    }, {\n      key: \"parseLogicalOr\",\n      value: function () {\n        for (var e = this.parseLogicalAnd(); this.optionalOperator(\"||\");) {\n          var t = this.parseLogicalAnd();\n          e = new K(this.span(e.span.start), \"||\", e, t);\n        }\n\n        return e;\n      }\n    }, {\n      key: \"parseLogicalAnd\",\n      value: function () {\n        for (var e = this.parseEquality(); this.optionalOperator(\"&&\");) {\n          var t = this.parseEquality();\n          e = new K(this.span(e.span.start), \"&&\", e, t);\n        }\n\n        return e;\n      }\n    }, {\n      key: \"parseEquality\",\n      value: function () {\n        for (var e = this.parseRelational(); this.next.type == D.Operator;) {\n          var t = this.next.strValue;\n\n          switch (t) {\n            case \"==\":\n            case \"===\":\n            case \"!=\":\n            case \"!==\":\n              this.advance();\n              var n = this.parseRelational();\n              e = new K(this.span(e.span.start), t, e, n);\n              continue;\n          }\n\n          break;\n        }\n\n        return e;\n      }\n    }, {\n      key: \"parseRelational\",\n      value: function () {\n        for (var e = this.parseAdditive(); this.next.type == D.Operator;) {\n          var t = this.next.strValue;\n\n          switch (t) {\n            case \"<\":\n            case \">\":\n            case \"<=\":\n            case \">=\":\n              this.advance();\n              var n = this.parseAdditive();\n              e = new K(this.span(e.span.start), t, e, n);\n              continue;\n          }\n\n          break;\n        }\n\n        return e;\n      }\n    }, {\n      key: \"parseAdditive\",\n      value: function () {\n        for (var e = this.parseMultiplicative(); this.next.type == D.Operator;) {\n          var t = this.next.strValue;\n\n          switch (t) {\n            case \"+\":\n            case \"-\":\n              this.advance();\n              var n = this.parseMultiplicative();\n              e = new K(this.span(e.span.start), t, e, n);\n              continue;\n          }\n\n          break;\n        }\n\n        return e;\n      }\n    }, {\n      key: \"parseMultiplicative\",\n      value: function () {\n        for (var e = this.parsePrefix(); this.next.type == D.Operator;) {\n          var t = this.next.strValue;\n\n          switch (t) {\n            case \"*\":\n            case \"%\":\n            case \"/\":\n              this.advance();\n              var n = this.parsePrefix();\n              e = new K(this.span(e.span.start), t, e, n);\n              continue;\n          }\n\n          break;\n        }\n\n        return e;\n      }\n    }, {\n      key: \"parsePrefix\",\n      value: function () {\n        if (this.next.type == D.Operator) {\n          var e,\n              t = this.inputIndex,\n              n = this.next.strValue;\n\n          switch (n) {\n            case \"+\":\n              return this.advance(), e = this.parsePrefix(), new K(this.span(t), \"-\", e, new I(new x(t, t), 0));\n\n            case \"-\":\n              return this.advance(), e = this.parsePrefix(), new K(this.span(t), n, new I(new x(t, t), 0), e);\n\n            case \"!\":\n              return this.advance(), e = this.parsePrefix(), new B(this.span(t), e);\n          }\n        }\n\n        return this.parseCallChain();\n      }\n    }, {\n      key: \"parseCallChain\",\n      value: function () {\n        for (var e = this.parsePrimary();;) if (this.optionalCharacter(46)) e = this.parseAccessMemberOrMethodCall(e, !1);else if (this.optionalOperator(\"?.\")) e = this.parseAccessMemberOrMethodCall(e, !0);else if (this.optionalCharacter(91)) {\n          this.rbracketsExpected++;\n          var t = this.parsePipe();\n\n          if (this.rbracketsExpected--, this.expectCharacter(93), this.optionalOperator(\"=\")) {\n            var n = this.parseConditional();\n            e = new N(this.span(e.span.start), e, t, n);\n          } else e = new S(this.span(e.span.start), e, t);\n        } else if (this.optionalCharacter(40)) {\n          this.rparensExpected++;\n          var i = this.parseCallArguments();\n          this.rparensExpected--, this.expectCharacter(41), e = new F(this.span(e.span.start), e, i);\n        } else {\n          if (!this.optionalOperator(\"!\")) return e;\n          e = new T(this.span(e.span.start), e);\n        }\n      }\n    }, {\n      key: \"parsePrimary\",\n      value: function () {\n        var e = this.inputIndex;\n\n        if (this.optionalCharacter(40)) {\n          this.rparensExpected++;\n          var t = this.parsePipe();\n          return this.rparensExpected--, this.expectCharacter(41), t;\n        }\n\n        if (this.next.isKeywordNull()) return this.advance(), new I(this.span(e), null);\n        if (this.next.isKeywordUndefined()) return this.advance(), new I(this.span(e), void 0);\n        if (this.next.isKeywordTrue()) return this.advance(), new I(this.span(e), !0);\n        if (this.next.isKeywordFalse()) return this.advance(), new I(this.span(e), !1);\n        if (this.next.isKeywordThis()) return this.advance(), new w(this.span(e));\n\n        if (this.optionalCharacter(91)) {\n          this.rbracketsExpected++;\n          var n = this.parseExpressionList(93);\n          return this.rbracketsExpected--, this.expectCharacter(93), new _(this.span(e), n);\n        }\n\n        if (this.next.isCharacter(123)) return this.parseLiteralMap();\n        if (this.next.isIdentifier()) return this.parseAccessMemberOrMethodCall(new w(this.span(e)), !1);\n\n        if (this.next.isNumber()) {\n          var i = this.next.toNumber();\n          return this.advance(), new I(this.span(e), i);\n        }\n\n        if (this.next.isString()) {\n          var r = this.next.toString();\n          return this.advance(), new I(this.span(e), r);\n        }\n\n        return this.index >= this.tokens.length ? (this.error(\"Unexpected end of expression: \".concat(this.input)), new m(this.span(e))) : (this.error(\"Unexpected token \".concat(this.next)), new m(this.span(e)));\n      }\n    }, {\n      key: \"parseExpressionList\",\n      value: function (e) {\n        var t = [];\n        if (!this.next.isCharacter(e)) do {\n          t.push(this.parsePipe());\n        } while (this.optionalCharacter(44));\n        return t;\n      }\n    }, {\n      key: \"parseLiteralMap\",\n      value: function () {\n        var e = [],\n            t = [],\n            n = this.inputIndex;\n\n        if (this.expectCharacter(123), !this.optionalCharacter(125)) {\n          this.rbracesExpected++;\n\n          do {\n            var i = this.next.isString(),\n                r = this.expectIdentifierOrKeywordOrString();\n            e.push({\n              key: r,\n              quoted: i\n            }), this.expectCharacter(58), t.push(this.parsePipe());\n          } while (this.optionalCharacter(44));\n\n          this.rbracesExpected--, this.expectCharacter(125);\n        }\n\n        return new L(this.span(n), e, t);\n      }\n    }, {\n      key: \"parseAccessMemberOrMethodCall\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],\n            n = e.span.start,\n            i = this.expectIdentifierOrKeyword();\n\n        if (this.optionalCharacter(40)) {\n          this.rparensExpected++;\n          var r = this.parseCallArguments();\n          this.expectCharacter(41), this.rparensExpected--;\n          var s = this.span(n);\n          return t ? new j(s, e, i, r) : new R(s, e, i, r);\n        }\n\n        if (t) return this.optionalOperator(\"=\") ? (this.error(\"The '?.' operator cannot be used in the assignment\"), new m(this.span(n))) : new E(this.span(n), e, i);\n\n        if (this.optionalOperator(\"=\")) {\n          if (!this.parseAction) return this.error(\"Bindings cannot contain assignments\"), new m(this.span(n));\n          var a = this.parseConditional();\n          return new A(this.span(n), e, i, a);\n        }\n\n        return new b(this.span(n), e, i);\n      }\n    }, {\n      key: \"parseCallArguments\",\n      value: function () {\n        if (this.next.isCharacter(41)) return [];\n        var e = [];\n\n        do {\n          e.push(this.parsePipe());\n        } while (this.optionalCharacter(44));\n\n        return e;\n      }\n    }, {\n      key: \"expectTemplateBindingKey\",\n      value: function () {\n        var e = \"\",\n            t = !1;\n\n        do {\n          e += this.expectIdentifierOrKeywordOrString(), (t = this.optionalOperator(\"-\")) && (e += \"-\");\n        } while (t);\n\n        return e.toString();\n      }\n    }, {\n      key: \"parseTemplateBindings\",\n      value: function (e) {\n        var t = !0,\n            n = [];\n\n        do {\n          var i = this.inputIndex,\n              r = void 0,\n              s = void 0,\n              a = !1;\n          t ? (r = s = e, t = !1) : ((a = this.peekKeywordLet()) && this.advance(), r = this.expectTemplateBindingKey(), s = a ? r : e + r[0].toUpperCase() + r.substring(1), this.optionalCharacter(58));\n          var o = null,\n              u = null;\n          if (a) o = this.optionalOperator(\"=\") ? this.expectTemplateBindingKey() : \"$implicit\";else if (this.peekKeywordAs()) this.advance(), o = r, s = this.expectTemplateBindingKey(), a = !0;else if (this.next !== Ie && !this.peekKeywordLet()) {\n            var l = this.inputIndex,\n                c = this.parsePipe(),\n                h = this.input.substring(l - this.offset, this.inputIndex - this.offset);\n            u = new W(c, h, this.location, this.absoluteOffset, this.errors);\n          }\n\n          if (n.push(new G(this.span(i), s, a, o, u)), this.peekKeywordAs() && !a) {\n            var p = this.inputIndex;\n            this.advance();\n            var v = this.expectTemplateBindingKey();\n            n.push(new G(this.span(p), v, !0, s, null));\n          }\n\n          this.optionalCharacter(59) || this.optionalCharacter(44);\n        } while (this.index < this.tokens.length);\n\n        return new Ue(n, [], this.errors);\n      }\n    }, {\n      key: \"error\",\n      value: function (e) {\n        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;\n        this.errors.push(new y(e, this.input, this.locationText(t), this.location)), this.skip();\n      }\n    }, {\n      key: \"locationText\",\n      value: function () {\n        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;\n        return null == e && (e = this.index), e < this.tokens.length ? \"at column \".concat(this.tokens[e].index + 1, \" in\") : \"at the end of the expression\";\n      }\n    }, {\n      key: \"skip\",\n      value: function () {\n        for (var e = this.next; this.index < this.tokens.length && !e.isCharacter(59) && (this.rparensExpected <= 0 || !e.isCharacter(41)) && (this.rbracesExpected <= 0 || !e.isCharacter(125)) && (this.rbracketsExpected <= 0 || !e.isCharacter(93));) this.next.isError() && this.errors.push(new y(this.next.toString(), this.input, this.locationText(), this.location)), this.advance(), e = this.next;\n      }\n    }, {\n      key: \"next\",\n      get: function () {\n        return this.peek(0);\n      }\n    }, {\n      key: \"inputIndex\",\n      get: function () {\n        return this.index < this.tokens.length ? this.next.index + this.offset : this.inputLength + this.offset;\n      }\n    }]), e;\n  }(),\n      qe = function () {\n    function e() {\n      a(this, e), this.errors = [];\n    }\n\n    return u(e, [{\n      key: \"visitImplicitReceiver\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitInterpolation\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitLiteralPrimitive\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitPropertyRead\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitPropertyWrite\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitSafePropertyRead\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitMethodCall\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitSafeMethodCall\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitFunctionCall\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitLiteralArray\",\n      value: function (e, t) {\n        this.visitAll(e.expressions);\n      }\n    }, {\n      key: \"visitLiteralMap\",\n      value: function (e, t) {\n        this.visitAll(e.values);\n      }\n    }, {\n      key: \"visitBinary\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitPrefixNot\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitNonNullAssert\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitConditional\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitPipe\",\n      value: function (e, t) {\n        this.errors.push(\"pipes\");\n      }\n    }, {\n      key: \"visitKeyedRead\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitKeyedWrite\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitAll\",\n      value: function (e) {\n        var t = this;\n        return e.map(function (e) {\n          return e.visit(t);\n        });\n      }\n    }, {\n      key: \"visitChain\",\n      value: function (e, t) {}\n    }, {\n      key: \"visitQuote\",\n      value: function (e, t) {}\n    }], [{\n      key: \"check\",\n      value: function (t) {\n        var n = new e();\n        return t.visit(n), n.errors;\n      }\n    }]), e;\n  }(),\n      De = Object.freeze({\n    __proto__: null,\n    SplitInterpolation: Ge,\n    TemplateBindingParseResult: Ue,\n    Parser: ze,\n    _ParseAST: $e\n  }),\n      He = r(function (e, t) {\n    Object.defineProperty(t, \"__esModule\", {\n      value: !0\n    });\n    var n = \"angular-estree-parser\",\n        i = \"NgEstreeParser\";\n\n    function r() {\n      return new De.Parser(new je.Lexer());\n    }\n\n    function a(e, t) {\n      var n = r(),\n          i = u(e, n),\n          s = i.astInput,\n          a = i.comments,\n          l = t(s, n),\n          c = l.ast;\n      return o(l.errors), {\n        ast: c,\n        comments: a\n      };\n    }\n\n    function o(e) {\n      if (0 !== e.length) {\n        var t = v(e, 1)[0].message;\n        throw new SyntaxError(t.replace(/^Parser Error: | at column \\d+ in [^]*$/g, \"\"));\n      }\n    }\n\n    function u(e, t) {\n      var n = t._commentStart(e);\n\n      return null === n ? {\n        astInput: e,\n        comments: []\n      } : {\n        astInput: e.slice(0, n),\n        comments: [{\n          type: \"Comment\",\n          value: e.slice(n + \"//\".length),\n          span: {\n            start: n,\n            end: e.length\n          }\n        }]\n      };\n    }\n\n    function l(e, t) {\n      for (var n = e.start, i = e.end; i !== n && /\\s/.test(t[i - 1]);) i--;\n\n      for (; n !== i && /\\s/.test(t[n]);) n++;\n\n      return {\n        start: n,\n        end: i\n      };\n    }\n\n    function c(e, t) {\n      for (var n = e.start, i = e.end; i !== t.length && /\\s/.test(t[i]);) i++;\n\n      for (; 0 !== n && /\\s/.test(t[n - 1]);) n--;\n\n      return {\n        start: n,\n        end: i\n      };\n    }\n\n    function h(e, t) {\n      return \"(\" === t[e.start - 1] && \")\" === t[e.end] ? {\n        start: e.start - 1,\n        end: e.end + 1\n      } : e;\n    }\n\n    t.parseNgBinding = function (e) {\n      return a(e, function (e, t) {\n        return t.parseBinding(e, n);\n      });\n    }, t.parseNgSimpleBinding = function (e) {\n      return a(e, function (e, t) {\n        return t.parseSimpleBinding(e, n);\n      });\n    }, t.parseNgAction = function (e) {\n      return a(e, function (e, t) {\n        return t.parseAction(e, n);\n      });\n    }, t.parseNgTemplateBindings = function (e) {\n      var t = r().parseTemplateBindings(i, e, n),\n          s = t.templateBindings;\n      return o(t.errors), s;\n    }, t.parseNgInterpolation = function (e) {\n      var t = r(),\n          i = u(e, t),\n          a = i.astInput,\n          l = i.comments,\n          c = t.parseInterpolation(\"{{\" + a + \"}}\", n),\n          h = c.ast;\n      o(c.errors);\n      var p = h.expressions[0];\n      return function e(t, n) {\n        if (!t || \"object\" !== s(t)) return;\n        if (Array.isArray(t)) return t.forEach(function (t) {\n          return e(t, n);\n        });\n\n        for (var i = 0, r = Object.keys(t); i < r.length; i++) {\n          var a = r[i],\n              o = t[a];\n          \"span\" === a ? n(o) : e(o, n);\n        }\n      }(p, function (e) {\n        e.start -= \"{{\".length, e.end -= \"{{\".length;\n      }), {\n        ast: p,\n        comments: l\n      };\n    }, t.getNgType = function (e) {\n      return e instanceof H.Binary ? \"Binary\" : e instanceof H.BindingPipe ? \"BindingPipe\" : e instanceof H.Chain ? \"Chain\" : e instanceof H.Conditional ? \"Conditional\" : e instanceof H.EmptyExpr ? \"EmptyExpr\" : e instanceof H.FunctionCall ? \"FunctionCall\" : e instanceof H.ImplicitReceiver ? \"ImplicitReceiver\" : e instanceof H.KeyedRead ? \"KeyedRead\" : e instanceof H.KeyedWrite ? \"KeyedWrite\" : e instanceof H.LiteralArray ? \"LiteralArray\" : e instanceof H.LiteralMap ? \"LiteralMap\" : e instanceof H.LiteralPrimitive ? \"LiteralPrimitive\" : e instanceof H.MethodCall ? \"MethodCall\" : e instanceof H.NonNullAssert ? \"NonNullAssert\" : e instanceof H.PrefixNot ? \"PrefixNot\" : e instanceof H.PropertyRead ? \"PropertyRead\" : e instanceof H.PropertyWrite ? \"PropertyWrite\" : e instanceof H.Quote ? \"Quote\" : e instanceof H.SafeMethodCall ? \"SafeMethodCall\" : e instanceof H.SafePropertyRead ? \"SafePropertyRead\" : e.type;\n    }, t.fitSpans = function (e, t, n) {\n      for (var i = 0, r = {\n        start: e.start,\n        end: e.end\n      };;) {\n        var s = c(r, t),\n            a = h(s, t);\n        if (s.start === a.start && s.end === a.end) break;\n        r.start = a.start, r.end = a.end, i++;\n      }\n\n      return {\n        hasParens: 0 !== (n ? i - 1 : i),\n        outerSpan: l(n ? {\n          start: r.start + 1,\n          end: r.end - 1\n        } : r, t),\n        innerSpan: l(e, t)\n      };\n    }, t.findFrontChar = function (e, t, n) {\n      for (var i = t; !e.test(n[i]);) i--;\n\n      return i;\n    }, t.findBackChar = function (e, t, n) {\n      for (var i = t; !e.test(n[i]);) i++;\n\n      return i;\n    }, t.toLowerCamelCase = function (e) {\n      return e.slice(0, 1).toLowerCase() + e.slice(1);\n    }, t.getLast = function (e) {\n      return 0 === e.length ? void 0 : e[e.length - 1];\n    };\n  });\n\n  i(He);\n  He.parseNgBinding, He.parseNgSimpleBinding, He.parseNgAction, He.parseNgTemplateBindings, He.parseNgInterpolation, He.getNgType, He.fitSpans, He.findFrontChar, He.findBackChar, He.toLowerCamelCase, He.getLast;\n  var Je = r(function (e, t) {\n    function n(e, t, n, i) {\n      if (!n) {\n        var r = e.start,\n            s = e.end;\n        return {\n          start: r,\n          end: s,\n          loc: {\n            start: t.locator.locationForIndex(r),\n            end: t.locator.locationForIndex(s)\n          }\n        };\n      }\n\n      var a = He.fitSpans(e, t.text, i),\n          o = a.outerSpan,\n          u = a.innerSpan,\n          l = a.hasParens;\n      return Object.assign({\n        start: u.start,\n        end: u.end,\n        loc: {\n          start: t.locator.locationForIndex(u.start),\n          end: t.locator.locationForIndex(u.end)\n        }\n      }, l && {\n        extra: {\n          parenthesized: !0,\n          parenStart: o.start,\n          parenEnd: o.end\n        }\n      });\n    }\n\n    Object.defineProperty(t, \"__esModule\", {\n      value: !0\n    }), t.transform = function (e, i) {\n      var r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],\n          a = He.getNgType(e);\n\n      switch (a) {\n        case \"Binary\":\n          var o = e.left,\n              u = e.operation,\n              l = e.right,\n              c = l.span.start === l.span.end,\n              h = o.span.start === o.span.end;\n\n          if (c || h) {\n            var p = o.span.start === o.span.end ? Pe(l) : Pe(o);\n            return Ae(\"UnaryExpression\", {\n              prefix: !0,\n              argument: p,\n              operator: c ? \"+\" : \"-\"\n            }, {\n              start: e.span.start,\n              end: Le(p)\n            }, {\n              hasParentParens: r\n            });\n          }\n\n          var v = Pe(o),\n              f = Pe(l);\n          return Ae(\"&&\" === u || \"||\" === u ? \"LogicalExpression\" : \"BinaryExpression\", {\n            left: v,\n            right: f,\n            operator: u\n          }, {\n            start: _e(v),\n            end: Le(f)\n          }, {\n            hasParentParens: r\n          });\n\n        case \"BindingPipe\":\n          var d = e.exp,\n              y = e.name,\n              x = e.args,\n              g = Pe(d),\n              k = Ne(/\\S/, Ne(/\\|/, Le(g)) + 1),\n              m = Ae(\"Identifier\", {\n            name: y\n          }, {\n            start: k,\n            end: k + y.length\n          }),\n              w = x.map(Pe);\n          return Ae(\"NGPipeExpression\", {\n            left: g,\n            right: m,\n            arguments: w\n          }, {\n            start: _e(g),\n            end: Le(0 === w.length ? m : He.getLast(w))\n          }, {\n            hasParentParens: r\n          });\n\n        case \"Chain\":\n          var C = e.expressions;\n          return Ae(\"NGChainedExpression\", {\n            expressions: C.map(Pe)\n          }, e.span, {\n            hasParentParens: r\n          });\n\n        case \"Comment\":\n          var P = e.value;\n          return Ae(\"CommentLine\", {\n            value: P\n          }, e.span, {\n            processSpan: !1\n          });\n\n        case \"Conditional\":\n          var b = e.condition,\n              A = e.trueExp,\n              E = e.falseExp,\n              S = Pe(b),\n              N = Pe(A),\n              O = Pe(E);\n          return Ae(\"ConditionalExpression\", {\n            test: S,\n            consequent: N,\n            alternate: O\n          }, {\n            start: _e(S),\n            end: Le(O)\n          }, {\n            hasParentParens: r\n          });\n\n        case \"EmptyExpr\":\n          return Ae(\"NGEmptyExpression\", {}, e.span, {\n            hasParentParens: r\n          });\n\n        case \"FunctionCall\":\n          var I = e.target,\n              _ = e.args,\n              L = 1 === _.length ? [be(_[0])] : _.map(Pe),\n              M = Pe(I);\n          return Ae(\"CallExpression\", {\n            callee: M,\n            arguments: L\n          }, {\n            start: _e(M),\n            end: e.span.end\n          }, {\n            hasParentParens: r\n          });\n\n        case \"KeyedRead\":\n          var K = e.obj,\n              B = e.key,\n              T = Pe(K),\n              R = Pe(B);\n          return Ae(\"MemberExpression\", {\n            computed: !0,\n            object: T,\n            property: R\n          }, {\n            start: _e(T),\n            end: e.span.end\n          }, {\n            hasParentParens: r\n          });\n\n        case \"LiteralArray\":\n          var j = e.expressions;\n          return Ae(\"ArrayExpression\", {\n            elements: j.map(Pe)\n          }, e.span, {\n            hasParentParens: r\n          });\n\n        case \"LiteralMap\":\n          var F = e.keys,\n              V = e.values,\n              W = V.map(function (e) {\n            return Pe(e);\n          }),\n              G = F.map(function (t, n) {\n            var i = t.key,\n                r = t.quoted,\n                s = W[n],\n                a = {\n              start: Ne(/\\S/, 0 === n ? e.span.start + 1 : Ne(/,/, Le(W[n - 1])) + 1),\n              end: Se(/\\S/, Se(/:/, _e(s) - 1) - 1) + 1\n            },\n                o = r ? Ae(\"StringLiteral\", {\n              value: i\n            }, a) : Ae(\"Identifier\", {\n              name: i\n            }, a);\n            return Ae(\"ObjectProperty\", {\n              key: o,\n              value: s,\n              method: !1,\n              shorthand: !1,\n              computed: !1\n            }, {\n              start: _e(o),\n              end: Le(s)\n            });\n          });\n          return Ae(\"ObjectExpression\", {\n            properties: G\n          }, e.span, {\n            hasParentParens: r\n          });\n\n        case \"LiteralPrimitive\":\n          var U = e.value;\n\n          switch (s(U)) {\n            case \"boolean\":\n              return Ae(\"BooleanLiteral\", {\n                value: U\n              }, e.span, {\n                hasParentParens: r\n              });\n\n            case \"number\":\n              return Ae(\"NumericLiteral\", {\n                value: U\n              }, e.span, {\n                hasParentParens: r\n              });\n\n            case \"object\":\n              return Ae(\"NullLiteral\", {}, e.span, {\n                hasParentParens: r\n              });\n\n            case \"string\":\n              return Ae(\"StringLiteral\", {\n                value: U\n              }, e.span, {\n                hasParentParens: r\n              });\n\n            case \"undefined\":\n              return Ae(\"Identifier\", {\n                name: \"undefined\"\n              }, e.span, {\n                hasParentParens: r\n              });\n\n            default:\n              throw new Error(\"Unexpected LiteralPrimitive value type \".concat(s(U)));\n          }\n\n        case \"MethodCall\":\n        case \"SafeMethodCall\":\n          var Q = \"SafeMethodCall\" === a,\n              z = e.receiver,\n              $ = e.name,\n              q = e.args,\n              D = 1 === q.length ? [be(q[0])] : q.map(Pe),\n              H = Se(/\\S/, Se(/\\(/, (0 === D.length ? Se(/\\)/, e.span.end - 1) : _e(D[0])) - 1) - 1) + 1,\n              J = Ae(\"Identifier\", {\n            name: $\n          }, {\n            start: H - $.length,\n            end: H\n          }),\n              X = Ee(z, J, {\n            computed: !1,\n            optional: Q\n          }),\n              Y = Oe(X);\n          return Ae(Q || Y ? \"OptionalCallExpression\" : \"CallExpression\", {\n            callee: X,\n            arguments: D\n          }, {\n            start: _e(X),\n            end: e.span.end\n          }, {\n            hasParentParens: r\n          });\n\n        case \"NonNullAssert\":\n          var Z = e.expression,\n              ee = Pe(Z);\n          return Ae(\"TSNonNullExpression\", {\n            expression: ee\n          }, {\n            start: _e(ee),\n            end: e.span.end\n          }, {\n            hasParentParens: r\n          });\n\n        case \"PrefixNot\":\n          var te = e.expression,\n              ne = Pe(te);\n          return Ae(\"UnaryExpression\", {\n            prefix: !0,\n            operator: \"!\",\n            argument: ne\n          }, {\n            start: e.span.start,\n            end: Le(ne)\n          }, {\n            hasParentParens: r\n          });\n\n        case \"PropertyRead\":\n        case \"SafePropertyRead\":\n          var ie = \"SafePropertyRead\" === a,\n              re = e.receiver,\n              se = e.name,\n              ae = Se(/\\S/, e.span.end - 1) + 1,\n              oe = Ae(\"Identifier\", {\n            name: se\n          }, {\n            start: ae - se.length,\n            end: ae\n          }, re.span.start === re.span.end ? {\n            hasParentParens: r\n          } : {});\n          return Ee(re, oe, {\n            computed: !1,\n            optional: ie\n          }, {\n            hasParentParens: r\n          });\n\n        case \"KeyedWrite\":\n          var ue = e.obj,\n              le = e.key,\n              ce = e.value,\n              he = Pe(le),\n              pe = Pe(ce),\n              ve = Ee(ue, he, {\n            computed: !0,\n            optional: !1\n          }, {\n            end: Ne(/\\]/, Le(he)) + 1\n          });\n          return Ae(\"AssignmentExpression\", {\n            left: ve,\n            operator: \"=\",\n            right: pe\n          }, {\n            start: _e(ve),\n            end: Le(pe)\n          }, {\n            hasParentParens: r\n          });\n\n        case \"PropertyWrite\":\n          var fe = e.receiver,\n              de = e.name,\n              ye = e.value,\n              xe = Pe(ye),\n              ge = Se(/\\S/, Se(/=/, _e(xe) - 1) - 1) + 1,\n              ke = Ae(\"Identifier\", {\n            name: de\n          }, {\n            start: ge - de.length,\n            end: ge\n          }),\n              me = Ee(fe, ke, {\n            computed: !1,\n            optional: !1\n          });\n          return Ae(\"AssignmentExpression\", {\n            left: me,\n            operator: \"=\",\n            right: xe\n          }, {\n            start: _e(me),\n            end: Le(xe)\n          }, {\n            hasParentParens: r\n          });\n\n        case \"Quote\":\n          var we = e.prefix,\n              Ce = e.uninterpretedExpression;\n          return Ae(\"NGQuotedExpression\", {\n            prefix: we,\n            value: Ce\n          }, e.span, {\n            hasParentParens: r\n          });\n\n        default:\n          throw new Error(\"Unexpected node \".concat(a));\n      }\n\n      function Pe(e) {\n        return t.transform(e, i);\n      }\n\n      function be(e) {\n        return t.transform(e, i, !0);\n      }\n\n      function Ae(e, t, r) {\n        var s = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {},\n            a = s.processSpan,\n            o = void 0 === a || a,\n            u = s.hasParentParens,\n            l = void 0 !== u && u,\n            c = Object.assign({\n          type: e\n        }, n(r, i, o, l), t);\n\n        switch (e) {\n          case \"Identifier\":\n            var h = c;\n            h.loc.identifierName = h.name;\n            break;\n\n          case \"NumericLiteral\":\n            var p = c;\n            p.extra = Object.assign({}, p.extra, {\n              raw: i.text.slice(p.start, p.end),\n              rawValue: p.value\n            });\n            break;\n\n          case \"StringLiteral\":\n            var v = c;\n            v.extra = Object.assign({}, v.extra, {\n              raw: i.text.slice(v.start, v.end),\n              rawValue: v.value\n            });\n        }\n\n        return c;\n      }\n\n      function Ee(e, t, n) {\n        var i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {},\n            r = i.end,\n            s = void 0 === r ? Le(t) : r,\n            a = i.hasParentParens,\n            o = void 0 !== a && a;\n        if (e.span.start === e.span.end) return t;\n        var u = \"ImplicitReceiver\" === He.getNgType(e) ? Ae(\"ThisExpression\", {}, e.span) : Pe(e),\n            l = Oe(u);\n        return Ae(n.optional || l ? \"OptionalMemberExpression\" : \"MemberExpression\", Object.assign({\n          object: u,\n          property: t,\n          computed: n.computed\n        }, n.optional ? {\n          optional: !0\n        } : l ? {\n          optional: !1\n        } : null), {\n          start: _e(u),\n          end: s\n        }, {\n          hasParentParens: o\n        });\n      }\n\n      function Se(e, t) {\n        return He.findFrontChar(e, t, i.text);\n      }\n\n      function Ne(e, t) {\n        return He.findBackChar(e, t, i.text);\n      }\n\n      function Oe(e) {\n        return (\"OptionalCallExpression\" === e.type || \"OptionalMemberExpression\" === e.type) && !Ie(e);\n      }\n\n      function Ie(e) {\n        return e.extra && e.extra.parenthesized;\n      }\n\n      function _e(e) {\n        return Ie(e) ? e.extra.parenStart : e.start;\n      }\n\n      function Le(e) {\n        return Ie(e) ? e.extra.parenEnd : e.end;\n      }\n    }, t.transformSpan = n;\n  });\n  i(Je);\n  Je.transform, Je.transformSpan;\n  var Xe = r(function (e, t) {\n    Object.defineProperty(t, \"__esModule\", {\n      value: !0\n    }), t.transformTemplateBindings = function (e, t) {\n      for (var n = v(e, 1)[0], i = n.key, r = 0 === t.text.slice(n.span.start, n.span.end).trim().length ? e.slice(1) : e, s = [], a = null, o = 0; o < r.length; o++) {\n        var u = r[o],\n            l = u.key,\n            c = u.keyIsVar,\n            h = u.name,\n            p = u.span;\n        a && a.key === h && c && /^as\\s$/.test(t.text.slice(p.start, p.start + 3)) ? function () {\n          var e = x(He.findBackChar(/\\S/, p.start + 3, t.text), l),\n              n = y(\"NGMicrosyntaxKey\", {\n            name: l\n          }, e),\n              i = function (e, n) {\n            return Object.assign({}, e, Je.transformSpan({\n              start: e.start,\n              end: n\n            }, t));\n          },\n              r = function (e) {\n            return Object.assign({}, i(e, n.end), {\n              alias: n\n            });\n          },\n              a = s.pop();\n\n          if (\"NGMicrosyntaxExpression\" === a.type) s.push(r(a));else {\n            if (\"NGMicrosyntaxKeyedExpression\" !== a.type) throw new Error(\"Unexpected type \".concat(a.type));\n            var o = r(a.expression);\n            s.push(i(Object.assign({}, a, {\n              expression: o\n            }), o.end));\n          }\n        }() : s.push(f(u, o)), a = u;\n      }\n\n      return y(\"NGMicrosyntax\", {\n        body: s\n      }, 0 === s.length ? e[0].span : {\n        start: s[0].start,\n        end: s[s.length - 1].end\n      });\n\n      function f(e, n) {\n        var i = e.key,\n            r = e.keyIsVar,\n            s = e.name,\n            a = e.expression,\n            o = e.span;\n\n        if (r) {\n          if (/^let\\s$/.test(t.text.slice(o.start, o.start + 4))) {\n            var u = x(He.findBackChar(/\\S/, o.start + 4, t.text), i);\n            return y(\"NGMicrosyntaxLet\", {\n              key: y(\"NGMicrosyntaxKey\", {\n                name: i\n              }, u),\n              value: 0 === t.text.slice(u.end, o.end).trim().length ? null : y(\"NGMicrosyntaxKey\", {\n                name: s\n              }, {\n                start: He.findBackChar(/=/, u.end, t.text) + 1,\n                end: o.end\n              })\n            }, o);\n          }\n\n          var l = x(o.start, s);\n          return y(\"NGMicrosyntaxAs\", {\n            key: y(\"NGMicrosyntaxKey\", {\n              name: s\n            }, l),\n            alias: y(\"NGMicrosyntaxKey\", {\n              name: i\n            }, {\n              start: He.findBackChar(/\\S/, l.end, t.text) + \"as\".length,\n              end: o.end\n            })\n          }, o);\n        }\n\n        if (a) {\n          if (0 === n) return y(\"NGMicrosyntaxExpression\", {\n            expression: d(a.ast),\n            alias: null\n          }, o);\n          var c = d(a.ast),\n              h = c.start,\n              p = c.end,\n              v = g(i);\n          return y(\"NGMicrosyntaxKeyedExpression\", {\n            key: y(\"NGMicrosyntaxKey\", {\n              name: v\n            }, x(o.start, v)),\n            expression: y(\"NGMicrosyntaxExpression\", {\n              expression: c,\n              alias: null\n            }, {\n              start: h,\n              end: p\n            })\n          }, o);\n        }\n\n        return y(\"NGMicrosyntaxKey\", {\n          name: g(i)\n        }, o);\n      }\n\n      function d(e) {\n        return Je.transform(e, t);\n      }\n\n      function y(e, n, i) {\n        var r = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3];\n        return Object.assign({\n          type: e\n        }, Je.transformSpan(i, t, r, !1), n);\n      }\n\n      function x(e, n) {\n        if (\"'\" !== t.text[e] && '\"' !== t.text[e]) return {\n          start: e,\n          end: e + n.length\n        };\n\n        for (var i = t.text[e], r = 0, s = e + 1;;) {\n          var a = t.text[s];\n          if (a === i && r % 2 == 0) return {\n            start: e,\n            end: s + 1\n          };\n          \"\\\\\" === a ? r++ : r = 0, s++;\n        }\n      }\n\n      function g(e) {\n        return He.toLowerCamelCase(e.slice(i.length));\n      }\n    };\n  });\n  i(Xe);\n  Xe.transformTemplateBindings;\n  var Ye = r(function (e, t) {\n    function n(e, t) {\n      var n = t(e),\n          i = n.ast,\n          r = n.comments,\n          s = new d.Context(e),\n          a = function (e) {\n        return Je.transform(e, s);\n      },\n          o = a(i);\n\n      return o.comments = r.map(a), o;\n    }\n\n    Object.defineProperty(t, \"__esModule\", {\n      value: !0\n    }), t.parseBinding = function (e) {\n      return n(e, He.parseNgBinding);\n    }, t.parseSimpleBinding = function (e) {\n      return n(e, He.parseNgSimpleBinding);\n    }, t.parseInterpolation = function (e) {\n      return n(e, He.parseNgInterpolation);\n    }, t.parseAction = function (e) {\n      return n(e, He.parseNgAction);\n    }, t.parseTemplateBindings = function (e) {\n      return Xe.transformTemplateBindings(He.parseNgTemplateBindings(e), new d.Context(e));\n    };\n  });\n  i(Ye);\n  Ye.parseBinding, Ye.parseSimpleBinding, Ye.parseInterpolation, Ye.parseAction, Ye.parseTemplateBindings;\n\n  function Ze(e) {\n    return Object.assign({\n      astFormat: \"estree\",\n      parse: function (t, n, i) {\n        var r = e(t, Ye);\n        return {\n          type: \"NGRoot\",\n          node: \"__ng_action\" === i.parser && \"NGChainedExpression\" !== r.type ? Object.assign({}, r, {\n            type: \"NGChainedExpression\",\n            expressions: [r]\n          }) : r\n        };\n      }\n    }, n);\n  }\n\n  var et = {\n    parsers: {\n      __ng_action: Ze(function (e, t) {\n        return t.parseAction(e);\n      }),\n      __ng_binding: Ze(function (e, t) {\n        return t.parseBinding(e);\n      }),\n      __ng_interpolation: Ze(function (e, t) {\n        return t.parseInterpolation(e);\n      }),\n      __ng_directive: Ze(function (e, t) {\n        return t.parseTemplateBindings(e);\n      })\n    }\n  },\n      tt = et.parsers;\n  e.default = et, e.parsers = tt, Object.defineProperty(e, \"__esModule\", {\n    value: !0\n  });\n});","map":null,"metadata":{},"sourceType":"script"}