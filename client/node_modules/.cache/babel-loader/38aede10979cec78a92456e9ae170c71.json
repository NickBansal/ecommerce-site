{"ast":null,"code":"!function (e, n) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? n(exports) : \"function\" == typeof define && define.amd ? define([\"exports\"], n) : n(((e = e || self).prettierPlugins = e.prettierPlugins || {}, e.prettierPlugins.graphql = {}));\n}(this, function (e) {\n  \"use strict\";\n\n  function n(e) {\n    return (n = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (e) {\n      return typeof e;\n    } : function (e) {\n      return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n    })(e);\n  }\n\n  var t = function (e, n) {\n    var t = new SyntaxError(e + \" (\" + n.start.line + \":\" + n.start.column + \")\");\n    return t.loc = n, t;\n  };\n\n  var i = function (e) {\n    return /^\\s*#[^\\n\\S]*@(format|prettier)\\s*(\\n|$)/.test(e);\n  };\n\n  function r(e) {\n    return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, \"default\") ? e.default : e;\n  }\n\n  function o(e, n) {\n    return e(n = {\n      exports: {}\n    }, n.exports), n.exports;\n  }\n\n  var a = o(function (e, n) {\n    Object.defineProperty(n, \"__esModule\", {\n      value: !0\n    }), n.default = function (e, n) {\n      if (!Boolean(e)) throw new Error(n);\n    };\n  });\n  r(a);\n  var s = o(function (e, n) {\n    Object.defineProperty(n, \"__esModule\", {\n      value: !0\n    }), n.default = function (e) {\n      \"function\" == typeof Symbol && Symbol.toStringTag && Object.defineProperty(e.prototype, Symbol.toStringTag, {\n        get: function () {\n          return this.constructor.name;\n        }\n      });\n    };\n  });\n  r(s);\n  var c = o(function (e, n) {\n    Object.defineProperty(n, \"__esModule\", {\n      value: !0\n    }), n.Source = void 0;\n    var t = r(a),\n        i = r(s);\n\n    function r(e) {\n      return e && e.__esModule ? e : {\n        default: e\n      };\n    }\n\n    var o = function (e, n, i) {\n      this.body = e, this.name = n || \"GraphQL request\", this.locationOffset = i || {\n        line: 1,\n        column: 1\n      }, this.locationOffset.line > 0 || (0, t.default)(0, \"line in locationOffset is 1-indexed and must be positive\"), this.locationOffset.column > 0 || (0, t.default)(0, \"column in locationOffset is 1-indexed and must be positive\");\n    };\n\n    n.Source = o, (0, i.default)(o);\n  });\n  r(c);\n  c.Source;\n  var u = o(function (e, n) {\n    Object.defineProperty(n, \"__esModule\", {\n      value: !0\n    }), n.getLocation = function (e, n) {\n      var t,\n          i = /\\r\\n|[\\n\\r]/g,\n          r = 1,\n          o = n + 1;\n\n      for (; (t = i.exec(e.body)) && t.index < n;) r += 1, o = n + 1 - (t.index + t[0].length);\n\n      return {\n        line: r,\n        column: o\n      };\n    };\n  });\n  r(u);\n  u.getLocation;\n  var l = o(function (e, n) {\n    function t(e, n) {\n      var t = e.locationOffset.column - 1,\n          o = r(t) + e.body,\n          a = n.line - 1,\n          s = e.locationOffset.line - 1,\n          c = n.line + s,\n          u = 1 === n.line ? t : 0,\n          l = n.column + u,\n          d = \"\".concat(e.name, \":\").concat(c, \":\").concat(l, \"\\n\"),\n          p = o.split(/\\r\\n|[\\n\\r]/g),\n          f = p[a];\n\n      if (f.length > 120) {\n        for (var h = Math.floor(l / 80), T = l % 80, v = [], E = 0; E < f.length; E += 80) v.push(f.slice(E, E + 80));\n\n        return d + i([[\"\".concat(c), v[0]]].concat(v.slice(1, h + 1).map(function (e) {\n          return [\"\", e];\n        }), [[\" \", r(T - 1) + \"^\"], [\"\", v[h + 1]]]));\n      }\n\n      return d + i([[\"\".concat(c - 1), p[a - 1]], [\"\".concat(c), f], [\"\", r(l - 1) + \"^\"], [\"\".concat(c + 1), p[a + 1]]]);\n    }\n\n    function i(e) {\n      var n = e.filter(function (e) {\n        e[0];\n        return void 0 !== e[1];\n      }),\n          t = Math.max.apply(Math, n.map(function (e) {\n        return e[0].length;\n      }));\n      return n.map(function (e) {\n        var n,\n            i = e[0],\n            o = e[1];\n        return r(t - (n = i).length) + n + (o ? \" | \" + o : \" |\");\n      }).join(\"\\n\");\n    }\n\n    function r(e) {\n      return Array(e + 1).join(\" \");\n    }\n\n    Object.defineProperty(n, \"__esModule\", {\n      value: !0\n    }), n.printLocation = function (e) {\n      return t(e.source, (0, u.getLocation)(e.source, e.start));\n    }, n.printSourceLocation = t;\n  });\n  r(l);\n  l.printLocation, l.printSourceLocation;\n  var d = o(function (e, n) {\n    Object.defineProperty(n, \"__esModule\", {\n      value: !0\n    }), n.Kind = void 0;\n    var t = Object.freeze({\n      NAME: \"Name\",\n      DOCUMENT: \"Document\",\n      OPERATION_DEFINITION: \"OperationDefinition\",\n      VARIABLE_DEFINITION: \"VariableDefinition\",\n      SELECTION_SET: \"SelectionSet\",\n      FIELD: \"Field\",\n      ARGUMENT: \"Argument\",\n      FRAGMENT_SPREAD: \"FragmentSpread\",\n      INLINE_FRAGMENT: \"InlineFragment\",\n      FRAGMENT_DEFINITION: \"FragmentDefinition\",\n      VARIABLE: \"Variable\",\n      INT: \"IntValue\",\n      FLOAT: \"FloatValue\",\n      STRING: \"StringValue\",\n      BOOLEAN: \"BooleanValue\",\n      NULL: \"NullValue\",\n      ENUM: \"EnumValue\",\n      LIST: \"ListValue\",\n      OBJECT: \"ObjectValue\",\n      OBJECT_FIELD: \"ObjectField\",\n      DIRECTIVE: \"Directive\",\n      NAMED_TYPE: \"NamedType\",\n      LIST_TYPE: \"ListType\",\n      NON_NULL_TYPE: \"NonNullType\",\n      SCHEMA_DEFINITION: \"SchemaDefinition\",\n      OPERATION_TYPE_DEFINITION: \"OperationTypeDefinition\",\n      SCALAR_TYPE_DEFINITION: \"ScalarTypeDefinition\",\n      OBJECT_TYPE_DEFINITION: \"ObjectTypeDefinition\",\n      FIELD_DEFINITION: \"FieldDefinition\",\n      INPUT_VALUE_DEFINITION: \"InputValueDefinition\",\n      INTERFACE_TYPE_DEFINITION: \"InterfaceTypeDefinition\",\n      UNION_TYPE_DEFINITION: \"UnionTypeDefinition\",\n      ENUM_TYPE_DEFINITION: \"EnumTypeDefinition\",\n      ENUM_VALUE_DEFINITION: \"EnumValueDefinition\",\n      INPUT_OBJECT_TYPE_DEFINITION: \"InputObjectTypeDefinition\",\n      DIRECTIVE_DEFINITION: \"DirectiveDefinition\",\n      SCHEMA_EXTENSION: \"SchemaExtension\",\n      SCALAR_TYPE_EXTENSION: \"ScalarTypeExtension\",\n      OBJECT_TYPE_EXTENSION: \"ObjectTypeExtension\",\n      INTERFACE_TYPE_EXTENSION: \"InterfaceTypeExtension\",\n      UNION_TYPE_EXTENSION: \"UnionTypeExtension\",\n      ENUM_TYPE_EXTENSION: \"EnumTypeExtension\",\n      INPUT_OBJECT_TYPE_EXTENSION: \"InputObjectTypeExtension\"\n    });\n    n.Kind = t;\n  });\n  r(d);\n  d.Kind;\n  var p = o(function (e, n) {\n    Object.defineProperty(n, \"__esModule\", {\n      value: !0\n    }), n.TokenKind = void 0;\n    var t = Object.freeze({\n      SOF: \"<SOF>\",\n      EOF: \"<EOF>\",\n      BANG: \"!\",\n      DOLLAR: \"$\",\n      AMP: \"&\",\n      PAREN_L: \"(\",\n      PAREN_R: \")\",\n      SPREAD: \"...\",\n      COLON: \":\",\n      EQUALS: \"=\",\n      AT: \"@\",\n      BRACKET_L: \"[\",\n      BRACKET_R: \"]\",\n      BRACE_L: \"{\",\n      PIPE: \"|\",\n      BRACE_R: \"}\",\n      NAME: \"Name\",\n      INT: \"Int\",\n      FLOAT: \"Float\",\n      STRING: \"String\",\n      BLOCK_STRING: \"BlockString\",\n      COMMENT: \"Comment\"\n    });\n    n.TokenKind = t;\n  });\n  r(p);\n  p.TokenKind;\n  var f = o(function (e, n) {\n    Object.defineProperty(n, \"__esModule\", {\n      value: !0\n    }), n.default = void 0;\n    var t = \"function\" == typeof Symbol && \"function\" == typeof Symbol.for ? Symbol.for(\"nodejs.util.inspect.custom\") : void 0;\n    n.default = t;\n  });\n  r(f);\n  var h = o(function (e, n) {\n    Object.defineProperty(n, \"__esModule\", {\n      value: !0\n    }), n.default = function (e) {\n      var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : e.prototype.toString;\n      e.prototype.toJSON = n, e.prototype.inspect = n, i.default && (e.prototype[i.default] = n);\n    };\n    var t,\n        i = (t = f) && t.__esModule ? t : {\n      default: t\n    };\n  });\n  r(h);\n  var T = o(function (e, t) {\n    function i(e) {\n      return (i = \"function\" == typeof Symbol && \"symbol\" === n(Symbol.iterator) ? function (e) {\n        return n(e);\n      } : function (e) {\n        return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : n(e);\n      })(e);\n    }\n\n    Object.defineProperty(t, \"__esModule\", {\n      value: !0\n    }), t.default = function (e) {\n      return \"object\" == i(e) && null !== e;\n    };\n  });\n  r(T);\n  var v = o(function (e, n) {\n    Object.defineProperty(n, \"__esModule\", {\n      value: !0\n    }), n.GraphQLError = r, n.printError = o;\n    var t,\n        i = (t = T) && t.__esModule ? t : {\n      default: t\n    };\n\n    function r(e, n, t, o, a, s, c) {\n      var l = Array.isArray(n) ? 0 !== n.length ? n : void 0 : n ? [n] : void 0,\n          d = t;\n\n      if (!d && l) {\n        var p = l[0];\n        d = p && p.loc && p.loc.source;\n      }\n\n      var f,\n          h = o;\n      !h && l && (h = l.reduce(function (e, n) {\n        return n.loc && e.push(n.loc.start), e;\n      }, [])), h && 0 === h.length && (h = void 0), o && t ? f = o.map(function (e) {\n        return (0, u.getLocation)(t, e);\n      }) : l && (f = l.reduce(function (e, n) {\n        return n.loc && e.push((0, u.getLocation)(n.loc.source, n.loc.start)), e;\n      }, []));\n      var T = c;\n\n      if (null == T && null != s) {\n        var v = s.extensions;\n        (0, i.default)(v) && (T = v);\n      }\n\n      Object.defineProperties(this, {\n        message: {\n          value: e,\n          enumerable: !0,\n          writable: !0\n        },\n        locations: {\n          value: f || void 0,\n          enumerable: Boolean(f)\n        },\n        path: {\n          value: a || void 0,\n          enumerable: Boolean(a)\n        },\n        nodes: {\n          value: l || void 0\n        },\n        source: {\n          value: d || void 0\n        },\n        positions: {\n          value: h || void 0\n        },\n        originalError: {\n          value: s\n        },\n        extensions: {\n          value: T || void 0,\n          enumerable: Boolean(T)\n        }\n      }), s && s.stack ? Object.defineProperty(this, \"stack\", {\n        value: s.stack,\n        writable: !0,\n        configurable: !0\n      }) : Error.captureStackTrace ? Error.captureStackTrace(this, r) : Object.defineProperty(this, \"stack\", {\n        value: Error().stack,\n        writable: !0,\n        configurable: !0\n      });\n    }\n\n    function o(e) {\n      var n = e.message;\n      if (e.nodes) for (var t = 0, i = e.nodes; t < i.length; t++) {\n        var r = i[t];\n        r.loc && (n += \"\\n\\n\" + (0, l.printLocation)(r.loc));\n      } else if (e.source && e.locations) for (var o = 0, a = e.locations; o < a.length; o++) {\n        var s = a[o];\n        n += \"\\n\\n\" + (0, l.printSourceLocation)(e.source, s);\n      }\n      return n;\n    }\n\n    r.prototype = Object.create(Error.prototype, {\n      constructor: {\n        value: r\n      },\n      name: {\n        value: \"GraphQLError\"\n      },\n      toString: {\n        value: function () {\n          return o(this);\n        }\n      }\n    });\n  });\n  r(v);\n  v.GraphQLError, v.printError;\n  var E = o(function (e, n) {\n    Object.defineProperty(n, \"__esModule\", {\n      value: !0\n    }), n.syntaxError = function (e, n, t) {\n      return new v.GraphQLError(\"Syntax Error: \".concat(t), void 0, e, [n]);\n    };\n  });\n  r(E);\n  E.syntaxError;\n  var y = o(function (e, n) {\n    function t(e) {\n      for (var n = null, t = 1; t < e.length; t++) {\n        var r = e[t],\n            o = i(r);\n        if (o !== r.length && (null === n || o < n) && 0 === (n = o)) break;\n      }\n\n      return null === n ? 0 : n;\n    }\n\n    function i(e) {\n      for (var n = 0; n < e.length && (\" \" === e[n] || \"\\t\" === e[n]);) n++;\n\n      return n;\n    }\n\n    function r(e) {\n      return i(e) === e.length;\n    }\n\n    Object.defineProperty(n, \"__esModule\", {\n      value: !0\n    }), n.dedentBlockStringValue = function (e) {\n      var n = e.split(/\\r\\n|[\\n\\r]/g),\n          i = t(n);\n      if (0 !== i) for (var o = 1; o < n.length; o++) n[o] = n[o].slice(i);\n\n      for (; n.length > 0 && r(n[0]);) n.shift();\n\n      for (; n.length > 0 && r(n[n.length - 1]);) n.pop();\n\n      return n.join(\"\\n\");\n    }, n.getBlockStringIndentation = t, n.printBlockString = function (e) {\n      var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : \"\",\n          t = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],\n          i = -1 === e.indexOf(\"\\n\"),\n          r = \" \" === e[0] || \"\\t\" === e[0],\n          o = '\"' === e[e.length - 1],\n          a = !i || o || t,\n          s = \"\";\n      !a || i && r || (s += \"\\n\" + n);\n      s += n ? e.replace(/\\n/g, \"\\n\" + n) : e, a && (s += \"\\n\");\n      return '\"\"\"' + s.replace(/\"\"\"/g, '\\\\\"\"\"') + '\"\"\"';\n    };\n  });\n  r(y);\n  y.dedentBlockStringValue, y.getBlockStringIndentation, y.printBlockString;\n  var N = o(function (e, n) {\n    var t;\n\n    function i() {\n      return this.lastToken = this.token, this.token = this.lookahead();\n    }\n\n    function r() {\n      var e = this.token;\n      if (e.kind !== p.TokenKind.EOF) do {\n        e = e.next || (e.next = s(this, e));\n      } while (e.kind === p.TokenKind.COMMENT);\n      return e;\n    }\n\n    function o(e, n, t, i, r, o, a) {\n      this.kind = e, this.start = n, this.end = t, this.line = i, this.column = r, this.value = a, this.prev = o, this.next = null;\n    }\n\n    function a(e) {\n      return isNaN(e) ? p.TokenKind.EOF : e < 127 ? JSON.stringify(String.fromCharCode(e)) : '\"\\\\u'.concat((\"00\" + e.toString(16).toUpperCase()).slice(-4), '\"');\n    }\n\n    function s(e, n) {\n      var t = e.source,\n          i = t.body,\n          r = i.length,\n          s = function (e, n, t) {\n        var i = e.length,\n            r = n;\n\n        for (; r < i;) {\n          var o = e.charCodeAt(r);\n          if (9 === o || 32 === o || 44 === o || 65279 === o) ++r;else if (10 === o) ++r, ++t.line, t.lineStart = r;else {\n            if (13 !== o) break;\n            10 === e.charCodeAt(r + 1) ? r += 2 : ++r, ++t.line, t.lineStart = r;\n          }\n        }\n\n        return r;\n      }(i, n.end, e),\n          l = e.line,\n          d = 1 + s - e.lineStart;\n\n      if (s >= r) return new o(p.TokenKind.EOF, r, r, l, d, n);\n      var f = i.charCodeAt(s);\n\n      switch (f) {\n        case 33:\n          return new o(p.TokenKind.BANG, s, s + 1, l, d, n);\n\n        case 35:\n          return function (e, n, t, i, r) {\n            var a,\n                s = e.body,\n                c = n;\n\n            do {\n              a = s.charCodeAt(++c);\n            } while (!isNaN(a) && (a > 31 || 9 === a));\n\n            return new o(p.TokenKind.COMMENT, n, c, t, i, r, s.slice(n + 1, c));\n          }(t, s, l, d, n);\n\n        case 36:\n          return new o(p.TokenKind.DOLLAR, s, s + 1, l, d, n);\n\n        case 38:\n          return new o(p.TokenKind.AMP, s, s + 1, l, d, n);\n\n        case 40:\n          return new o(p.TokenKind.PAREN_L, s, s + 1, l, d, n);\n\n        case 41:\n          return new o(p.TokenKind.PAREN_R, s, s + 1, l, d, n);\n\n        case 46:\n          if (46 === i.charCodeAt(s + 1) && 46 === i.charCodeAt(s + 2)) return new o(p.TokenKind.SPREAD, s, s + 3, l, d, n);\n          break;\n\n        case 58:\n          return new o(p.TokenKind.COLON, s, s + 1, l, d, n);\n\n        case 61:\n          return new o(p.TokenKind.EQUALS, s, s + 1, l, d, n);\n\n        case 64:\n          return new o(p.TokenKind.AT, s, s + 1, l, d, n);\n\n        case 91:\n          return new o(p.TokenKind.BRACKET_L, s, s + 1, l, d, n);\n\n        case 93:\n          return new o(p.TokenKind.BRACKET_R, s, s + 1, l, d, n);\n\n        case 123:\n          return new o(p.TokenKind.BRACE_L, s, s + 1, l, d, n);\n\n        case 124:\n          return new o(p.TokenKind.PIPE, s, s + 1, l, d, n);\n\n        case 125:\n          return new o(p.TokenKind.BRACE_R, s, s + 1, l, d, n);\n\n        case 65:\n        case 66:\n        case 67:\n        case 68:\n        case 69:\n        case 70:\n        case 71:\n        case 72:\n        case 73:\n        case 74:\n        case 75:\n        case 76:\n        case 77:\n        case 78:\n        case 79:\n        case 80:\n        case 81:\n        case 82:\n        case 83:\n        case 84:\n        case 85:\n        case 86:\n        case 87:\n        case 88:\n        case 89:\n        case 90:\n        case 95:\n        case 97:\n        case 98:\n        case 99:\n        case 100:\n        case 101:\n        case 102:\n        case 103:\n        case 104:\n        case 105:\n        case 106:\n        case 107:\n        case 108:\n        case 109:\n        case 110:\n        case 111:\n        case 112:\n        case 113:\n        case 114:\n        case 115:\n        case 116:\n        case 117:\n        case 118:\n        case 119:\n        case 120:\n        case 121:\n        case 122:\n          return function (e, n, t, i, r) {\n            var a = e.body,\n                s = a.length,\n                c = n + 1,\n                u = 0;\n\n            for (; c !== s && !isNaN(u = a.charCodeAt(c)) && (95 === u || u >= 48 && u <= 57 || u >= 65 && u <= 90 || u >= 97 && u <= 122);) ++c;\n\n            return new o(p.TokenKind.NAME, n, c, t, i, r, a.slice(n, c));\n          }(t, s, l, d, n);\n\n        case 45:\n        case 48:\n        case 49:\n        case 50:\n        case 51:\n        case 52:\n        case 53:\n        case 54:\n        case 55:\n        case 56:\n        case 57:\n          return function (e, n, t, i, r, s) {\n            var u = e.body,\n                l = t,\n                d = n,\n                f = !1;\n            45 === l && (l = u.charCodeAt(++d));\n\n            if (48 === l) {\n              if ((l = u.charCodeAt(++d)) >= 48 && l <= 57) throw (0, E.syntaxError)(e, d, \"Invalid number, unexpected digit after 0: \".concat(a(l), \".\"));\n            } else d = c(e, d, l), l = u.charCodeAt(d);\n\n            46 === l && (f = !0, l = u.charCodeAt(++d), d = c(e, d, l), l = u.charCodeAt(d));\n            69 !== l && 101 !== l || (f = !0, 43 !== (l = u.charCodeAt(++d)) && 45 !== l || (l = u.charCodeAt(++d)), d = c(e, d, l), l = u.charCodeAt(d));\n            if (46 === l || 69 === l || 101 === l) throw (0, E.syntaxError)(e, d, \"Invalid number, expected digit but got: \".concat(a(l), \".\"));\n            return new o(f ? p.TokenKind.FLOAT : p.TokenKind.INT, n, d, i, r, s, u.slice(n, d));\n          }(t, s, f, l, d, n);\n\n        case 34:\n          return 34 === i.charCodeAt(s + 1) && 34 === i.charCodeAt(s + 2) ? function (e, n, t, i, r, s) {\n            var c = e.body,\n                u = n + 3,\n                l = u,\n                d = 0,\n                f = \"\";\n\n            for (; u < c.length && !isNaN(d = c.charCodeAt(u));) {\n              if (34 === d && 34 === c.charCodeAt(u + 1) && 34 === c.charCodeAt(u + 2)) return f += c.slice(l, u), new o(p.TokenKind.BLOCK_STRING, n, u + 3, t, i, r, (0, y.dedentBlockStringValue)(f));\n              if (d < 32 && 9 !== d && 10 !== d && 13 !== d) throw (0, E.syntaxError)(e, u, \"Invalid character within String: \".concat(a(d), \".\"));\n              10 === d ? (++u, ++s.line, s.lineStart = u) : 13 === d ? (10 === c.charCodeAt(u + 1) ? u += 2 : ++u, ++s.line, s.lineStart = u) : 92 === d && 34 === c.charCodeAt(u + 1) && 34 === c.charCodeAt(u + 2) && 34 === c.charCodeAt(u + 3) ? (f += c.slice(l, u) + '\"\"\"', l = u += 4) : ++u;\n            }\n\n            throw (0, E.syntaxError)(e, u, \"Unterminated string.\");\n          }(t, s, l, d, n, e) : function (e, n, t, i, r) {\n            var s = e.body,\n                c = n + 1,\n                l = c,\n                d = 0,\n                f = \"\";\n\n            for (; c < s.length && !isNaN(d = s.charCodeAt(c)) && 10 !== d && 13 !== d;) {\n              if (34 === d) return f += s.slice(l, c), new o(p.TokenKind.STRING, n, c + 1, t, i, r, f);\n              if (d < 32 && 9 !== d) throw (0, E.syntaxError)(e, c, \"Invalid character within String: \".concat(a(d), \".\"));\n\n              if (++c, 92 === d) {\n                switch (f += s.slice(l, c - 1), d = s.charCodeAt(c)) {\n                  case 34:\n                    f += '\"';\n                    break;\n\n                  case 47:\n                    f += \"/\";\n                    break;\n\n                  case 92:\n                    f += \"\\\\\";\n                    break;\n\n                  case 98:\n                    f += \"\\b\";\n                    break;\n\n                  case 102:\n                    f += \"\\f\";\n                    break;\n\n                  case 110:\n                    f += \"\\n\";\n                    break;\n\n                  case 114:\n                    f += \"\\r\";\n                    break;\n\n                  case 116:\n                    f += \"\\t\";\n                    break;\n\n                  case 117:\n                    var h = (v = s.charCodeAt(c + 1), y = s.charCodeAt(c + 2), N = s.charCodeAt(c + 3), m = s.charCodeAt(c + 4), u(v) << 12 | u(y) << 8 | u(N) << 4 | u(m));\n\n                    if (h < 0) {\n                      var T = s.slice(c + 1, c + 5);\n                      throw (0, E.syntaxError)(e, c, \"Invalid character escape sequence: \\\\u\".concat(T, \".\"));\n                    }\n\n                    f += String.fromCharCode(h), c += 4;\n                    break;\n\n                  default:\n                    throw (0, E.syntaxError)(e, c, \"Invalid character escape sequence: \\\\\".concat(String.fromCharCode(d), \".\"));\n                }\n\n                l = ++c;\n              }\n            }\n\n            var v, y, N, m;\n            throw (0, E.syntaxError)(e, c, \"Unterminated string.\");\n          }(t, s, l, d, n);\n      }\n\n      throw (0, E.syntaxError)(t, s, function (e) {\n        if (e < 32 && 9 !== e && 10 !== e && 13 !== e) return \"Cannot contain the invalid character \".concat(a(e), \".\");\n        if (39 === e) return \"Unexpected single quote character ('), did you mean to use a double quote (\\\")?\";\n        return \"Cannot parse the unexpected character \".concat(a(e), \".\");\n      }(f));\n    }\n\n    function c(e, n, t) {\n      var i = e.body,\n          r = n,\n          o = t;\n\n      if (o >= 48 && o <= 57) {\n        do {\n          o = i.charCodeAt(++r);\n        } while (o >= 48 && o <= 57);\n\n        return r;\n      }\n\n      throw (0, E.syntaxError)(e, r, \"Invalid number, expected digit but got: \".concat(a(o), \".\"));\n    }\n\n    function u(e) {\n      return e >= 48 && e <= 57 ? e - 48 : e >= 65 && e <= 70 ? e - 55 : e >= 97 && e <= 102 ? e - 87 : -1;\n    }\n\n    Object.defineProperty(n, \"__esModule\", {\n      value: !0\n    }), n.createLexer = function (e, n) {\n      var t = new o(p.TokenKind.SOF, 0, 0, 0, 0, null);\n      return {\n        source: e,\n        options: n,\n        lastToken: t,\n        token: t,\n        line: 1,\n        lineStart: 0,\n        advance: i,\n        lookahead: r\n      };\n    }, n.isPunctuatorToken = function (e) {\n      var n = e.kind;\n      return n === p.TokenKind.BANG || n === p.TokenKind.DOLLAR || n === p.TokenKind.AMP || n === p.TokenKind.PAREN_L || n === p.TokenKind.PAREN_R || n === p.TokenKind.SPREAD || n === p.TokenKind.COLON || n === p.TokenKind.EQUALS || n === p.TokenKind.AT || n === p.TokenKind.BRACKET_L || n === p.TokenKind.BRACKET_R || n === p.TokenKind.BRACE_L || n === p.TokenKind.PIPE || n === p.TokenKind.BRACE_R;\n    }, (0, ((t = h) && t.__esModule ? t : {\n      default: t\n    }).default)(o, function () {\n      return {\n        kind: this.kind,\n        value: this.value,\n        line: this.line,\n        column: this.column\n      };\n    });\n  });\n  r(N);\n  N.createLexer, N.isPunctuatorToken;\n  var m = o(function (e, t) {\n    Object.defineProperty(t, \"__esModule\", {\n      value: !0\n    }), t.default = function (e) {\n      return c(e, []);\n    };\n    var i,\n        r = (i = f) && i.__esModule ? i : {\n      default: i\n    };\n\n    function o(e) {\n      return (o = \"function\" == typeof Symbol && \"symbol\" === n(Symbol.iterator) ? function (e) {\n        return n(e);\n      } : function (e) {\n        return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : n(e);\n      })(e);\n    }\n\n    var a = 10,\n        s = 2;\n\n    function c(e, n) {\n      switch (o(e)) {\n        case \"string\":\n          return JSON.stringify(e);\n\n        case \"function\":\n          return e.name ? \"[function \".concat(e.name, \"]\") : \"[function]\";\n\n        case \"object\":\n          return null === e ? \"null\" : function (e, n) {\n            if (-1 !== n.indexOf(e)) return \"[Circular]\";\n\n            var t = [].concat(n, [e]),\n                i = function (e) {\n              var n = e[String(r.default)];\n              if (\"function\" == typeof n) return n;\n              if (\"function\" == typeof e.inspect) return e.inspect;\n            }(e);\n\n            if (void 0 !== i) {\n              var o = i.call(e);\n              if (o !== e) return \"string\" == typeof o ? o : c(o, t);\n            } else if (Array.isArray(e)) return function (e, n) {\n              if (0 === e.length) return \"[]\";\n              if (n.length > s) return \"[Array]\";\n\n              for (var t = Math.min(a, e.length), i = e.length - t, r = [], o = 0; o < t; ++o) r.push(c(e[o], n));\n\n              1 === i ? r.push(\"... 1 more item\") : i > 1 && r.push(\"... \".concat(i, \" more items\"));\n              return \"[\" + r.join(\", \") + \"]\";\n            }(e, t);\n\n            return function (e, n) {\n              var t = Object.keys(e);\n              if (0 === t.length) return \"{}\";\n              if (n.length > s) return \"[\" + function (e) {\n                var n = Object.prototype.toString.call(e).replace(/^\\[object /, \"\").replace(/]$/, \"\");\n\n                if (\"Object\" === n && \"function\" == typeof e.constructor) {\n                  var t = e.constructor.name;\n                  if (\"string\" == typeof t && \"\" !== t) return t;\n                }\n\n                return n;\n              }(e) + \"]\";\n              return \"{ \" + t.map(function (t) {\n                return t + \": \" + c(e[t], n);\n              }).join(\", \") + \" }\";\n            }(e, t);\n          }(e, n);\n\n        default:\n          return String(e);\n      }\n    }\n  });\n  r(m);\n  var k = o(function (e, n) {\n    Object.defineProperty(n, \"__esModule\", {\n      value: !0\n    }), n.DirectiveLocation = void 0;\n    var t = Object.freeze({\n      QUERY: \"QUERY\",\n      MUTATION: \"MUTATION\",\n      SUBSCRIPTION: \"SUBSCRIPTION\",\n      FIELD: \"FIELD\",\n      FRAGMENT_DEFINITION: \"FRAGMENT_DEFINITION\",\n      FRAGMENT_SPREAD: \"FRAGMENT_SPREAD\",\n      INLINE_FRAGMENT: \"INLINE_FRAGMENT\",\n      VARIABLE_DEFINITION: \"VARIABLE_DEFINITION\",\n      SCHEMA: \"SCHEMA\",\n      SCALAR: \"SCALAR\",\n      OBJECT: \"OBJECT\",\n      FIELD_DEFINITION: \"FIELD_DEFINITION\",\n      ARGUMENT_DEFINITION: \"ARGUMENT_DEFINITION\",\n      INTERFACE: \"INTERFACE\",\n      UNION: \"UNION\",\n      ENUM: \"ENUM\",\n      ENUM_VALUE: \"ENUM_VALUE\",\n      INPUT_OBJECT: \"INPUT_OBJECT\",\n      INPUT_FIELD_DEFINITION: \"INPUT_FIELD_DEFINITION\"\n    });\n    n.DirectiveLocation = t;\n  });\n  r(k);\n  k.DirectiveLocation;\n  var I = o(function (e, n) {\n    Object.defineProperty(n, \"__esModule\", {\n      value: !0\n    }), n.parse = function (e, n) {\n      return new s(e, n).parseDocument();\n    }, n.parseValue = function (e, n) {\n      var t = new s(e, n);\n      t.expectToken(p.TokenKind.SOF);\n      var i = t.parseValueLiteral(!1);\n      return t.expectToken(p.TokenKind.EOF), i;\n    }, n.parseType = function (e, n) {\n      var t = new s(e, n);\n      t.expectToken(p.TokenKind.SOF);\n      var i = t.parseTypeReference();\n      return t.expectToken(p.TokenKind.EOF), i;\n    };\n    var t = o(m),\n        i = o(a),\n        r = o(h);\n\n    function o(e) {\n      return e && e.__esModule ? e : {\n        default: e\n      };\n    }\n\n    var s = function () {\n      function e(e, n) {\n        var r = \"string\" == typeof e ? new c.Source(e) : e;\n        r instanceof c.Source || (0, i.default)(0, \"Must provide Source. Received: \".concat((0, t.default)(r))), this._lexer = (0, N.createLexer)(r), this._options = n || {};\n      }\n\n      var n = e.prototype;\n      return n.parseName = function () {\n        var e = this.expectToken(p.TokenKind.NAME);\n        return {\n          kind: d.Kind.NAME,\n          value: e.value,\n          loc: this.loc(e)\n        };\n      }, n.parseDocument = function () {\n        var e = this._lexer.token;\n        return {\n          kind: d.Kind.DOCUMENT,\n          definitions: this.many(p.TokenKind.SOF, this.parseDefinition, p.TokenKind.EOF),\n          loc: this.loc(e)\n        };\n      }, n.parseDefinition = function () {\n        if (this.peek(p.TokenKind.NAME)) switch (this._lexer.token.value) {\n          case \"query\":\n          case \"mutation\":\n          case \"subscription\":\n            return this.parseOperationDefinition();\n\n          case \"fragment\":\n            return this.parseFragmentDefinition();\n\n          case \"schema\":\n          case \"scalar\":\n          case \"type\":\n          case \"interface\":\n          case \"union\":\n          case \"enum\":\n          case \"input\":\n          case \"directive\":\n            return this.parseTypeSystemDefinition();\n\n          case \"extend\":\n            return this.parseTypeSystemExtension();\n        } else {\n          if (this.peek(p.TokenKind.BRACE_L)) return this.parseOperationDefinition();\n          if (this.peekDescription()) return this.parseTypeSystemDefinition();\n        }\n        throw this.unexpected();\n      }, n.parseOperationDefinition = function () {\n        var e = this._lexer.token;\n        if (this.peek(p.TokenKind.BRACE_L)) return {\n          kind: d.Kind.OPERATION_DEFINITION,\n          operation: \"query\",\n          name: void 0,\n          variableDefinitions: [],\n          directives: [],\n          selectionSet: this.parseSelectionSet(),\n          loc: this.loc(e)\n        };\n        var n,\n            t = this.parseOperationType();\n        return this.peek(p.TokenKind.NAME) && (n = this.parseName()), {\n          kind: d.Kind.OPERATION_DEFINITION,\n          operation: t,\n          name: n,\n          variableDefinitions: this.parseVariableDefinitions(),\n          directives: this.parseDirectives(!1),\n          selectionSet: this.parseSelectionSet(),\n          loc: this.loc(e)\n        };\n      }, n.parseOperationType = function () {\n        var e = this.expectToken(p.TokenKind.NAME);\n\n        switch (e.value) {\n          case \"query\":\n            return \"query\";\n\n          case \"mutation\":\n            return \"mutation\";\n\n          case \"subscription\":\n            return \"subscription\";\n        }\n\n        throw this.unexpected(e);\n      }, n.parseVariableDefinitions = function () {\n        return this.optionalMany(p.TokenKind.PAREN_L, this.parseVariableDefinition, p.TokenKind.PAREN_R);\n      }, n.parseVariableDefinition = function () {\n        var e = this._lexer.token;\n        return {\n          kind: d.Kind.VARIABLE_DEFINITION,\n          variable: this.parseVariable(),\n          type: (this.expectToken(p.TokenKind.COLON), this.parseTypeReference()),\n          defaultValue: this.expectOptionalToken(p.TokenKind.EQUALS) ? this.parseValueLiteral(!0) : void 0,\n          directives: this.parseDirectives(!0),\n          loc: this.loc(e)\n        };\n      }, n.parseVariable = function () {\n        var e = this._lexer.token;\n        return this.expectToken(p.TokenKind.DOLLAR), {\n          kind: d.Kind.VARIABLE,\n          name: this.parseName(),\n          loc: this.loc(e)\n        };\n      }, n.parseSelectionSet = function () {\n        var e = this._lexer.token;\n        return {\n          kind: d.Kind.SELECTION_SET,\n          selections: this.many(p.TokenKind.BRACE_L, this.parseSelection, p.TokenKind.BRACE_R),\n          loc: this.loc(e)\n        };\n      }, n.parseSelection = function () {\n        return this.peek(p.TokenKind.SPREAD) ? this.parseFragment() : this.parseField();\n      }, n.parseField = function () {\n        var e,\n            n,\n            t = this._lexer.token,\n            i = this.parseName();\n        return this.expectOptionalToken(p.TokenKind.COLON) ? (e = i, n = this.parseName()) : n = i, {\n          kind: d.Kind.FIELD,\n          alias: e,\n          name: n,\n          arguments: this.parseArguments(!1),\n          directives: this.parseDirectives(!1),\n          selectionSet: this.peek(p.TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0,\n          loc: this.loc(t)\n        };\n      }, n.parseArguments = function (e) {\n        var n = e ? this.parseConstArgument : this.parseArgument;\n        return this.optionalMany(p.TokenKind.PAREN_L, n, p.TokenKind.PAREN_R);\n      }, n.parseArgument = function () {\n        var e = this._lexer.token,\n            n = this.parseName();\n        return this.expectToken(p.TokenKind.COLON), {\n          kind: d.Kind.ARGUMENT,\n          name: n,\n          value: this.parseValueLiteral(!1),\n          loc: this.loc(e)\n        };\n      }, n.parseConstArgument = function () {\n        var e = this._lexer.token;\n        return {\n          kind: d.Kind.ARGUMENT,\n          name: this.parseName(),\n          value: (this.expectToken(p.TokenKind.COLON), this.parseValueLiteral(!0)),\n          loc: this.loc(e)\n        };\n      }, n.parseFragment = function () {\n        var e = this._lexer.token;\n        this.expectToken(p.TokenKind.SPREAD);\n        var n = this.expectOptionalKeyword(\"on\");\n        return !n && this.peek(p.TokenKind.NAME) ? {\n          kind: d.Kind.FRAGMENT_SPREAD,\n          name: this.parseFragmentName(),\n          directives: this.parseDirectives(!1),\n          loc: this.loc(e)\n        } : {\n          kind: d.Kind.INLINE_FRAGMENT,\n          typeCondition: n ? this.parseNamedType() : void 0,\n          directives: this.parseDirectives(!1),\n          selectionSet: this.parseSelectionSet(),\n          loc: this.loc(e)\n        };\n      }, n.parseFragmentDefinition = function () {\n        var e = this._lexer.token;\n        return this.expectKeyword(\"fragment\"), this._options.experimentalFragmentVariables ? {\n          kind: d.Kind.FRAGMENT_DEFINITION,\n          name: this.parseFragmentName(),\n          variableDefinitions: this.parseVariableDefinitions(),\n          typeCondition: (this.expectKeyword(\"on\"), this.parseNamedType()),\n          directives: this.parseDirectives(!1),\n          selectionSet: this.parseSelectionSet(),\n          loc: this.loc(e)\n        } : {\n          kind: d.Kind.FRAGMENT_DEFINITION,\n          name: this.parseFragmentName(),\n          typeCondition: (this.expectKeyword(\"on\"), this.parseNamedType()),\n          directives: this.parseDirectives(!1),\n          selectionSet: this.parseSelectionSet(),\n          loc: this.loc(e)\n        };\n      }, n.parseFragmentName = function () {\n        if (\"on\" === this._lexer.token.value) throw this.unexpected();\n        return this.parseName();\n      }, n.parseValueLiteral = function (e) {\n        var n = this._lexer.token;\n\n        switch (n.kind) {\n          case p.TokenKind.BRACKET_L:\n            return this.parseList(e);\n\n          case p.TokenKind.BRACE_L:\n            return this.parseObject(e);\n\n          case p.TokenKind.INT:\n            return this._lexer.advance(), {\n              kind: d.Kind.INT,\n              value: n.value,\n              loc: this.loc(n)\n            };\n\n          case p.TokenKind.FLOAT:\n            return this._lexer.advance(), {\n              kind: d.Kind.FLOAT,\n              value: n.value,\n              loc: this.loc(n)\n            };\n\n          case p.TokenKind.STRING:\n          case p.TokenKind.BLOCK_STRING:\n            return this.parseStringLiteral();\n\n          case p.TokenKind.NAME:\n            return \"true\" === n.value || \"false\" === n.value ? (this._lexer.advance(), {\n              kind: d.Kind.BOOLEAN,\n              value: \"true\" === n.value,\n              loc: this.loc(n)\n            }) : \"null\" === n.value ? (this._lexer.advance(), {\n              kind: d.Kind.NULL,\n              loc: this.loc(n)\n            }) : (this._lexer.advance(), {\n              kind: d.Kind.ENUM,\n              value: n.value,\n              loc: this.loc(n)\n            });\n\n          case p.TokenKind.DOLLAR:\n            if (!e) return this.parseVariable();\n        }\n\n        throw this.unexpected();\n      }, n.parseStringLiteral = function () {\n        var e = this._lexer.token;\n        return this._lexer.advance(), {\n          kind: d.Kind.STRING,\n          value: e.value,\n          block: e.kind === p.TokenKind.BLOCK_STRING,\n          loc: this.loc(e)\n        };\n      }, n.parseList = function (e) {\n        var n = this,\n            t = this._lexer.token;\n        return {\n          kind: d.Kind.LIST,\n          values: this.any(p.TokenKind.BRACKET_L, function () {\n            return n.parseValueLiteral(e);\n          }, p.TokenKind.BRACKET_R),\n          loc: this.loc(t)\n        };\n      }, n.parseObject = function (e) {\n        var n = this,\n            t = this._lexer.token;\n        return {\n          kind: d.Kind.OBJECT,\n          fields: this.any(p.TokenKind.BRACE_L, function () {\n            return n.parseObjectField(e);\n          }, p.TokenKind.BRACE_R),\n          loc: this.loc(t)\n        };\n      }, n.parseObjectField = function (e) {\n        var n = this._lexer.token,\n            t = this.parseName();\n        return this.expectToken(p.TokenKind.COLON), {\n          kind: d.Kind.OBJECT_FIELD,\n          name: t,\n          value: this.parseValueLiteral(e),\n          loc: this.loc(n)\n        };\n      }, n.parseDirectives = function (e) {\n        for (var n = []; this.peek(p.TokenKind.AT);) n.push(this.parseDirective(e));\n\n        return n;\n      }, n.parseDirective = function (e) {\n        var n = this._lexer.token;\n        return this.expectToken(p.TokenKind.AT), {\n          kind: d.Kind.DIRECTIVE,\n          name: this.parseName(),\n          arguments: this.parseArguments(e),\n          loc: this.loc(n)\n        };\n      }, n.parseTypeReference = function () {\n        var e,\n            n = this._lexer.token;\n        return this.expectOptionalToken(p.TokenKind.BRACKET_L) ? (e = this.parseTypeReference(), this.expectToken(p.TokenKind.BRACKET_R), e = {\n          kind: d.Kind.LIST_TYPE,\n          type: e,\n          loc: this.loc(n)\n        }) : e = this.parseNamedType(), this.expectOptionalToken(p.TokenKind.BANG) ? {\n          kind: d.Kind.NON_NULL_TYPE,\n          type: e,\n          loc: this.loc(n)\n        } : e;\n      }, n.parseNamedType = function () {\n        var e = this._lexer.token;\n        return {\n          kind: d.Kind.NAMED_TYPE,\n          name: this.parseName(),\n          loc: this.loc(e)\n        };\n      }, n.parseTypeSystemDefinition = function () {\n        var e = this.peekDescription() ? this._lexer.lookahead() : this._lexer.token;\n        if (e.kind === p.TokenKind.NAME) switch (e.value) {\n          case \"schema\":\n            return this.parseSchemaDefinition();\n\n          case \"scalar\":\n            return this.parseScalarTypeDefinition();\n\n          case \"type\":\n            return this.parseObjectTypeDefinition();\n\n          case \"interface\":\n            return this.parseInterfaceTypeDefinition();\n\n          case \"union\":\n            return this.parseUnionTypeDefinition();\n\n          case \"enum\":\n            return this.parseEnumTypeDefinition();\n\n          case \"input\":\n            return this.parseInputObjectTypeDefinition();\n\n          case \"directive\":\n            return this.parseDirectiveDefinition();\n        }\n        throw this.unexpected(e);\n      }, n.peekDescription = function () {\n        return this.peek(p.TokenKind.STRING) || this.peek(p.TokenKind.BLOCK_STRING);\n      }, n.parseDescription = function () {\n        if (this.peekDescription()) return this.parseStringLiteral();\n      }, n.parseSchemaDefinition = function () {\n        var e = this._lexer.token;\n        this.expectKeyword(\"schema\");\n        var n = this.parseDirectives(!0),\n            t = this.many(p.TokenKind.BRACE_L, this.parseOperationTypeDefinition, p.TokenKind.BRACE_R);\n        return {\n          kind: d.Kind.SCHEMA_DEFINITION,\n          directives: n,\n          operationTypes: t,\n          loc: this.loc(e)\n        };\n      }, n.parseOperationTypeDefinition = function () {\n        var e = this._lexer.token,\n            n = this.parseOperationType();\n        this.expectToken(p.TokenKind.COLON);\n        var t = this.parseNamedType();\n        return {\n          kind: d.Kind.OPERATION_TYPE_DEFINITION,\n          operation: n,\n          type: t,\n          loc: this.loc(e)\n        };\n      }, n.parseScalarTypeDefinition = function () {\n        var e = this._lexer.token,\n            n = this.parseDescription();\n        this.expectKeyword(\"scalar\");\n        var t = this.parseName(),\n            i = this.parseDirectives(!0);\n        return {\n          kind: d.Kind.SCALAR_TYPE_DEFINITION,\n          description: n,\n          name: t,\n          directives: i,\n          loc: this.loc(e)\n        };\n      }, n.parseObjectTypeDefinition = function () {\n        var e = this._lexer.token,\n            n = this.parseDescription();\n        this.expectKeyword(\"type\");\n        var t = this.parseName(),\n            i = this.parseImplementsInterfaces(),\n            r = this.parseDirectives(!0),\n            o = this.parseFieldsDefinition();\n        return {\n          kind: d.Kind.OBJECT_TYPE_DEFINITION,\n          description: n,\n          name: t,\n          interfaces: i,\n          directives: r,\n          fields: o,\n          loc: this.loc(e)\n        };\n      }, n.parseImplementsInterfaces = function () {\n        var e = [];\n\n        if (this.expectOptionalKeyword(\"implements\")) {\n          this.expectOptionalToken(p.TokenKind.AMP);\n\n          do {\n            e.push(this.parseNamedType());\n          } while (this.expectOptionalToken(p.TokenKind.AMP) || this._options.allowLegacySDLImplementsInterfaces && this.peek(p.TokenKind.NAME));\n        }\n\n        return e;\n      }, n.parseFieldsDefinition = function () {\n        return this._options.allowLegacySDLEmptyFields && this.peek(p.TokenKind.BRACE_L) && this._lexer.lookahead().kind === p.TokenKind.BRACE_R ? (this._lexer.advance(), this._lexer.advance(), []) : this.optionalMany(p.TokenKind.BRACE_L, this.parseFieldDefinition, p.TokenKind.BRACE_R);\n      }, n.parseFieldDefinition = function () {\n        var e = this._lexer.token,\n            n = this.parseDescription(),\n            t = this.parseName(),\n            i = this.parseArgumentDefs();\n        this.expectToken(p.TokenKind.COLON);\n        var r = this.parseTypeReference(),\n            o = this.parseDirectives(!0);\n        return {\n          kind: d.Kind.FIELD_DEFINITION,\n          description: n,\n          name: t,\n          arguments: i,\n          type: r,\n          directives: o,\n          loc: this.loc(e)\n        };\n      }, n.parseArgumentDefs = function () {\n        return this.optionalMany(p.TokenKind.PAREN_L, this.parseInputValueDef, p.TokenKind.PAREN_R);\n      }, n.parseInputValueDef = function () {\n        var e = this._lexer.token,\n            n = this.parseDescription(),\n            t = this.parseName();\n        this.expectToken(p.TokenKind.COLON);\n        var i,\n            r = this.parseTypeReference();\n        this.expectOptionalToken(p.TokenKind.EQUALS) && (i = this.parseValueLiteral(!0));\n        var o = this.parseDirectives(!0);\n        return {\n          kind: d.Kind.INPUT_VALUE_DEFINITION,\n          description: n,\n          name: t,\n          type: r,\n          defaultValue: i,\n          directives: o,\n          loc: this.loc(e)\n        };\n      }, n.parseInterfaceTypeDefinition = function () {\n        var e = this._lexer.token,\n            n = this.parseDescription();\n        this.expectKeyword(\"interface\");\n        var t = this.parseName(),\n            i = this.parseDirectives(!0),\n            r = this.parseFieldsDefinition();\n        return {\n          kind: d.Kind.INTERFACE_TYPE_DEFINITION,\n          description: n,\n          name: t,\n          directives: i,\n          fields: r,\n          loc: this.loc(e)\n        };\n      }, n.parseUnionTypeDefinition = function () {\n        var e = this._lexer.token,\n            n = this.parseDescription();\n        this.expectKeyword(\"union\");\n        var t = this.parseName(),\n            i = this.parseDirectives(!0),\n            r = this.parseUnionMemberTypes();\n        return {\n          kind: d.Kind.UNION_TYPE_DEFINITION,\n          description: n,\n          name: t,\n          directives: i,\n          types: r,\n          loc: this.loc(e)\n        };\n      }, n.parseUnionMemberTypes = function () {\n        var e = [];\n\n        if (this.expectOptionalToken(p.TokenKind.EQUALS)) {\n          this.expectOptionalToken(p.TokenKind.PIPE);\n\n          do {\n            e.push(this.parseNamedType());\n          } while (this.expectOptionalToken(p.TokenKind.PIPE));\n        }\n\n        return e;\n      }, n.parseEnumTypeDefinition = function () {\n        var e = this._lexer.token,\n            n = this.parseDescription();\n        this.expectKeyword(\"enum\");\n        var t = this.parseName(),\n            i = this.parseDirectives(!0),\n            r = this.parseEnumValuesDefinition();\n        return {\n          kind: d.Kind.ENUM_TYPE_DEFINITION,\n          description: n,\n          name: t,\n          directives: i,\n          values: r,\n          loc: this.loc(e)\n        };\n      }, n.parseEnumValuesDefinition = function () {\n        return this.optionalMany(p.TokenKind.BRACE_L, this.parseEnumValueDefinition, p.TokenKind.BRACE_R);\n      }, n.parseEnumValueDefinition = function () {\n        var e = this._lexer.token,\n            n = this.parseDescription(),\n            t = this.parseName(),\n            i = this.parseDirectives(!0);\n        return {\n          kind: d.Kind.ENUM_VALUE_DEFINITION,\n          description: n,\n          name: t,\n          directives: i,\n          loc: this.loc(e)\n        };\n      }, n.parseInputObjectTypeDefinition = function () {\n        var e = this._lexer.token,\n            n = this.parseDescription();\n        this.expectKeyword(\"input\");\n        var t = this.parseName(),\n            i = this.parseDirectives(!0),\n            r = this.parseInputFieldsDefinition();\n        return {\n          kind: d.Kind.INPUT_OBJECT_TYPE_DEFINITION,\n          description: n,\n          name: t,\n          directives: i,\n          fields: r,\n          loc: this.loc(e)\n        };\n      }, n.parseInputFieldsDefinition = function () {\n        return this.optionalMany(p.TokenKind.BRACE_L, this.parseInputValueDef, p.TokenKind.BRACE_R);\n      }, n.parseTypeSystemExtension = function () {\n        var e = this._lexer.lookahead();\n\n        if (e.kind === p.TokenKind.NAME) switch (e.value) {\n          case \"schema\":\n            return this.parseSchemaExtension();\n\n          case \"scalar\":\n            return this.parseScalarTypeExtension();\n\n          case \"type\":\n            return this.parseObjectTypeExtension();\n\n          case \"interface\":\n            return this.parseInterfaceTypeExtension();\n\n          case \"union\":\n            return this.parseUnionTypeExtension();\n\n          case \"enum\":\n            return this.parseEnumTypeExtension();\n\n          case \"input\":\n            return this.parseInputObjectTypeExtension();\n        }\n        throw this.unexpected(e);\n      }, n.parseSchemaExtension = function () {\n        var e = this._lexer.token;\n        this.expectKeyword(\"extend\"), this.expectKeyword(\"schema\");\n        var n = this.parseDirectives(!0),\n            t = this.optionalMany(p.TokenKind.BRACE_L, this.parseOperationTypeDefinition, p.TokenKind.BRACE_R);\n        if (0 === n.length && 0 === t.length) throw this.unexpected();\n        return {\n          kind: d.Kind.SCHEMA_EXTENSION,\n          directives: n,\n          operationTypes: t,\n          loc: this.loc(e)\n        };\n      }, n.parseScalarTypeExtension = function () {\n        var e = this._lexer.token;\n        this.expectKeyword(\"extend\"), this.expectKeyword(\"scalar\");\n        var n = this.parseName(),\n            t = this.parseDirectives(!0);\n        if (0 === t.length) throw this.unexpected();\n        return {\n          kind: d.Kind.SCALAR_TYPE_EXTENSION,\n          name: n,\n          directives: t,\n          loc: this.loc(e)\n        };\n      }, n.parseObjectTypeExtension = function () {\n        var e = this._lexer.token;\n        this.expectKeyword(\"extend\"), this.expectKeyword(\"type\");\n        var n = this.parseName(),\n            t = this.parseImplementsInterfaces(),\n            i = this.parseDirectives(!0),\n            r = this.parseFieldsDefinition();\n        if (0 === t.length && 0 === i.length && 0 === r.length) throw this.unexpected();\n        return {\n          kind: d.Kind.OBJECT_TYPE_EXTENSION,\n          name: n,\n          interfaces: t,\n          directives: i,\n          fields: r,\n          loc: this.loc(e)\n        };\n      }, n.parseInterfaceTypeExtension = function () {\n        var e = this._lexer.token;\n        this.expectKeyword(\"extend\"), this.expectKeyword(\"interface\");\n        var n = this.parseName(),\n            t = this.parseDirectives(!0),\n            i = this.parseFieldsDefinition();\n        if (0 === t.length && 0 === i.length) throw this.unexpected();\n        return {\n          kind: d.Kind.INTERFACE_TYPE_EXTENSION,\n          name: n,\n          directives: t,\n          fields: i,\n          loc: this.loc(e)\n        };\n      }, n.parseUnionTypeExtension = function () {\n        var e = this._lexer.token;\n        this.expectKeyword(\"extend\"), this.expectKeyword(\"union\");\n        var n = this.parseName(),\n            t = this.parseDirectives(!0),\n            i = this.parseUnionMemberTypes();\n        if (0 === t.length && 0 === i.length) throw this.unexpected();\n        return {\n          kind: d.Kind.UNION_TYPE_EXTENSION,\n          name: n,\n          directives: t,\n          types: i,\n          loc: this.loc(e)\n        };\n      }, n.parseEnumTypeExtension = function () {\n        var e = this._lexer.token;\n        this.expectKeyword(\"extend\"), this.expectKeyword(\"enum\");\n        var n = this.parseName(),\n            t = this.parseDirectives(!0),\n            i = this.parseEnumValuesDefinition();\n        if (0 === t.length && 0 === i.length) throw this.unexpected();\n        return {\n          kind: d.Kind.ENUM_TYPE_EXTENSION,\n          name: n,\n          directives: t,\n          values: i,\n          loc: this.loc(e)\n        };\n      }, n.parseInputObjectTypeExtension = function () {\n        var e = this._lexer.token;\n        this.expectKeyword(\"extend\"), this.expectKeyword(\"input\");\n        var n = this.parseName(),\n            t = this.parseDirectives(!0),\n            i = this.parseInputFieldsDefinition();\n        if (0 === t.length && 0 === i.length) throw this.unexpected();\n        return {\n          kind: d.Kind.INPUT_OBJECT_TYPE_EXTENSION,\n          name: n,\n          directives: t,\n          fields: i,\n          loc: this.loc(e)\n        };\n      }, n.parseDirectiveDefinition = function () {\n        var e = this._lexer.token,\n            n = this.parseDescription();\n        this.expectKeyword(\"directive\"), this.expectToken(p.TokenKind.AT);\n        var t = this.parseName(),\n            i = this.parseArgumentDefs(),\n            r = this.expectOptionalKeyword(\"repeatable\");\n        this.expectKeyword(\"on\");\n        var o = this.parseDirectiveLocations();\n        return {\n          kind: d.Kind.DIRECTIVE_DEFINITION,\n          description: n,\n          name: t,\n          arguments: i,\n          repeatable: r,\n          locations: o,\n          loc: this.loc(e)\n        };\n      }, n.parseDirectiveLocations = function () {\n        this.expectOptionalToken(p.TokenKind.PIPE);\n        var e = [];\n\n        do {\n          e.push(this.parseDirectiveLocation());\n        } while (this.expectOptionalToken(p.TokenKind.PIPE));\n\n        return e;\n      }, n.parseDirectiveLocation = function () {\n        var e = this._lexer.token,\n            n = this.parseName();\n        if (void 0 !== k.DirectiveLocation[n.value]) return n;\n        throw this.unexpected(e);\n      }, n.loc = function (e) {\n        if (!this._options.noLocation) return new u(e, this._lexer.lastToken, this._lexer.source);\n      }, n.peek = function (e) {\n        return this._lexer.token.kind === e;\n      }, n.expectToken = function (e) {\n        var n = this._lexer.token;\n        if (n.kind === e) return this._lexer.advance(), n;\n        throw (0, E.syntaxError)(this._lexer.source, n.start, \"Expected \".concat(e, \", found \").concat(l(n)));\n      }, n.expectOptionalToken = function (e) {\n        var n = this._lexer.token;\n        if (n.kind === e) return this._lexer.advance(), n;\n      }, n.expectKeyword = function (e) {\n        var n = this._lexer.token;\n        if (n.kind !== p.TokenKind.NAME || n.value !== e) throw (0, E.syntaxError)(this._lexer.source, n.start, 'Expected \"'.concat(e, '\", found ').concat(l(n)));\n\n        this._lexer.advance();\n      }, n.expectOptionalKeyword = function (e) {\n        var n = this._lexer.token;\n        return n.kind === p.TokenKind.NAME && n.value === e && (this._lexer.advance(), !0);\n      }, n.unexpected = function (e) {\n        var n = e || this._lexer.token;\n        return (0, E.syntaxError)(this._lexer.source, n.start, \"Unexpected \".concat(l(n)));\n      }, n.any = function (e, n, t) {\n        this.expectToken(e);\n\n        for (var i = []; !this.expectOptionalToken(t);) i.push(n.call(this));\n\n        return i;\n      }, n.optionalMany = function (e, n, t) {\n        if (this.expectOptionalToken(e)) {\n          var i = [];\n\n          do {\n            i.push(n.call(this));\n          } while (!this.expectOptionalToken(t));\n\n          return i;\n        }\n\n        return [];\n      }, n.many = function (e, n, t) {\n        this.expectToken(e);\n        var i = [];\n\n        do {\n          i.push(n.call(this));\n        } while (!this.expectOptionalToken(t));\n\n        return i;\n      }, e;\n    }();\n\n    function u(e, n, t) {\n      this.start = e.start, this.end = n.end, this.startToken = e, this.endToken = n, this.source = t;\n    }\n\n    function l(e) {\n      var n = e.value;\n      return n ? \"\".concat(e.kind, ' \"').concat(n, '\"') : e.kind;\n    }\n\n    (0, r.default)(u, function () {\n      return {\n        start: this.start,\n        end: this.end\n      };\n    });\n  });\n  r(I);\n  I.parse, I.parseValue, I.parseType;\n\n  var _ = o(function (e, n) {\n    Object.defineProperty(n, \"__esModule\", {\n      value: !0\n    }), n.visit = function (e, n) {\n      var t = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : r,\n          c = void 0,\n          u = Array.isArray(e),\n          l = [e],\n          d = -1,\n          p = [],\n          f = void 0,\n          h = void 0,\n          T = void 0,\n          v = [],\n          E = [],\n          y = e;\n\n      do {\n        var N = ++d === l.length,\n            m = N && 0 !== p.length;\n\n        if (N) {\n          if (h = 0 === E.length ? void 0 : v[v.length - 1], f = T, T = E.pop(), m) {\n            if (u) f = f.slice();else {\n              for (var k = {}, I = 0, _ = Object.keys(f); I < _.length; I++) {\n                var O = _[I];\n                k[O] = f[O];\n              }\n\n              f = k;\n            }\n\n            for (var D = 0, x = 0; x < p.length; x++) {\n              var K = p[x][0],\n                  A = p[x][1];\n              u && (K -= D), u && null === A ? (f.splice(K, 1), D++) : f[K] = A;\n            }\n          }\n\n          d = c.index, l = c.keys, p = c.edits, u = c.inArray, c = c.prev;\n        } else {\n          if (h = T ? u ? d : l[d] : void 0, null == (f = T ? T[h] : y)) continue;\n          T && v.push(h);\n        }\n\n        var b = void 0;\n\n        if (!Array.isArray(f)) {\n          if (!a(f)) throw new Error(\"Invalid AST Node: \" + (0, i.default)(f));\n          var S = s(n, f.kind, N);\n\n          if (S) {\n            if ((b = S.call(n, f, h, T, v, E)) === o) break;\n\n            if (!1 === b) {\n              if (!N) {\n                v.pop();\n                continue;\n              }\n            } else if (void 0 !== b && (p.push([h, b]), !N)) {\n              if (!a(b)) {\n                v.pop();\n                continue;\n              }\n\n              f = b;\n            }\n          }\n        }\n\n        void 0 === b && m && p.push([h, f]), N ? v.pop() : (c = {\n          inArray: u,\n          index: d,\n          keys: l,\n          edits: p,\n          prev: c\n        }, u = Array.isArray(f), l = u ? f : t[f.kind] || [], d = -1, p = [], T && E.push(T), T = f);\n      } while (void 0 !== c);\n\n      0 !== p.length && (y = p[p.length - 1][1]);\n      return y;\n    }, n.visitInParallel = function (e) {\n      var n = new Array(e.length);\n      return {\n        enter: function (t) {\n          for (var i = 0; i < e.length; i++) if (!n[i]) {\n            var r = s(e[i], t.kind, !1);\n\n            if (r) {\n              var a = r.apply(e[i], arguments);\n              if (!1 === a) n[i] = t;else if (a === o) n[i] = o;else if (void 0 !== a) return a;\n            }\n          }\n        },\n        leave: function (t) {\n          for (var i = 0; i < e.length; i++) if (n[i]) n[i] === t && (n[i] = null);else {\n            var r = s(e[i], t.kind, !0);\n\n            if (r) {\n              var a = r.apply(e[i], arguments);\n              if (a === o) n[i] = o;else if (void 0 !== a && !1 !== a) return a;\n            }\n          }\n        }\n      };\n    }, n.visitWithTypeInfo = function (e, n) {\n      return {\n        enter: function (t) {\n          e.enter(t);\n          var i = s(n, t.kind, !1);\n\n          if (i) {\n            var r = i.apply(n, arguments);\n            return void 0 !== r && (e.leave(t), a(r) && e.enter(r)), r;\n          }\n        },\n        leave: function (t) {\n          var i,\n              r = s(n, t.kind, !0);\n          return r && (i = r.apply(n, arguments)), e.leave(t), i;\n        }\n      };\n    }, n.getVisitFn = s, n.BREAK = n.QueryDocumentKeys = void 0;\n    var t,\n        i = (t = m) && t.__esModule ? t : {\n      default: t\n    };\n    var r = {\n      Name: [],\n      Document: [\"definitions\"],\n      OperationDefinition: [\"name\", \"variableDefinitions\", \"directives\", \"selectionSet\"],\n      VariableDefinition: [\"variable\", \"type\", \"defaultValue\", \"directives\"],\n      Variable: [\"name\"],\n      SelectionSet: [\"selections\"],\n      Field: [\"alias\", \"name\", \"arguments\", \"directives\", \"selectionSet\"],\n      Argument: [\"name\", \"value\"],\n      FragmentSpread: [\"name\", \"directives\"],\n      InlineFragment: [\"typeCondition\", \"directives\", \"selectionSet\"],\n      FragmentDefinition: [\"name\", \"variableDefinitions\", \"typeCondition\", \"directives\", \"selectionSet\"],\n      IntValue: [],\n      FloatValue: [],\n      StringValue: [],\n      BooleanValue: [],\n      NullValue: [],\n      EnumValue: [],\n      ListValue: [\"values\"],\n      ObjectValue: [\"fields\"],\n      ObjectField: [\"name\", \"value\"],\n      Directive: [\"name\", \"arguments\"],\n      NamedType: [\"name\"],\n      ListType: [\"type\"],\n      NonNullType: [\"type\"],\n      SchemaDefinition: [\"directives\", \"operationTypes\"],\n      OperationTypeDefinition: [\"type\"],\n      ScalarTypeDefinition: [\"description\", \"name\", \"directives\"],\n      ObjectTypeDefinition: [\"description\", \"name\", \"interfaces\", \"directives\", \"fields\"],\n      FieldDefinition: [\"description\", \"name\", \"arguments\", \"type\", \"directives\"],\n      InputValueDefinition: [\"description\", \"name\", \"type\", \"defaultValue\", \"directives\"],\n      InterfaceTypeDefinition: [\"description\", \"name\", \"directives\", \"fields\"],\n      UnionTypeDefinition: [\"description\", \"name\", \"directives\", \"types\"],\n      EnumTypeDefinition: [\"description\", \"name\", \"directives\", \"values\"],\n      EnumValueDefinition: [\"description\", \"name\", \"directives\"],\n      InputObjectTypeDefinition: [\"description\", \"name\", \"directives\", \"fields\"],\n      DirectiveDefinition: [\"description\", \"name\", \"arguments\", \"locations\"],\n      SchemaExtension: [\"directives\", \"operationTypes\"],\n      ScalarTypeExtension: [\"name\", \"directives\"],\n      ObjectTypeExtension: [\"name\", \"interfaces\", \"directives\", \"fields\"],\n      InterfaceTypeExtension: [\"name\", \"directives\", \"fields\"],\n      UnionTypeExtension: [\"name\", \"directives\", \"types\"],\n      EnumTypeExtension: [\"name\", \"directives\", \"values\"],\n      InputObjectTypeExtension: [\"name\", \"directives\", \"fields\"]\n    };\n    n.QueryDocumentKeys = r;\n    var o = Object.freeze({});\n\n    function a(e) {\n      return Boolean(e && \"string\" == typeof e.kind);\n    }\n\n    function s(e, n, t) {\n      var i = e[n];\n\n      if (i) {\n        if (!t && \"function\" == typeof i) return i;\n        var r = t ? i.leave : i.enter;\n        if (\"function\" == typeof r) return r;\n      } else {\n        var o = t ? e.leave : e.enter;\n\n        if (o) {\n          if (\"function\" == typeof o) return o;\n          var a = o[n];\n          if (\"function\" == typeof a) return a;\n        }\n      }\n    }\n\n    n.BREAK = o;\n  });\n\n  r(_);\n  _.visit, _.visitInParallel, _.visitWithTypeInfo, _.getVisitFn, _.BREAK, _.QueryDocumentKeys;\n  var O = o(function (e, n) {\n    Object.defineProperty(n, \"__esModule\", {\n      value: !0\n    }), n.print = function (e) {\n      return (0, _.visit)(e, {\n        leave: t\n      });\n    };\n    var t = {\n      Name: function (e) {\n        return e.value;\n      },\n      Variable: function (e) {\n        return \"$\" + e.name;\n      },\n      Document: function (e) {\n        return r(e.definitions, \"\\n\\n\") + \"\\n\";\n      },\n      OperationDefinition: function (e) {\n        var n = e.operation,\n            t = e.name,\n            i = a(\"(\", r(e.variableDefinitions, \", \"), \")\"),\n            o = r(e.directives, \" \"),\n            s = e.selectionSet;\n        return t || o || i || \"query\" !== n ? r([n, r([t, i]), o, s], \" \") : s;\n      },\n      VariableDefinition: function (e) {\n        var n = e.variable,\n            t = e.type,\n            i = e.defaultValue,\n            o = e.directives;\n        return n + \": \" + t + a(\" = \", i) + a(\" \", r(o, \" \"));\n      },\n      SelectionSet: function (e) {\n        return o(e.selections);\n      },\n      Field: function (e) {\n        var n = e.alias,\n            t = e.name,\n            i = e.arguments,\n            o = e.directives,\n            s = e.selectionSet;\n        return r([a(\"\", n, \": \") + t + a(\"(\", r(i, \", \"), \")\"), r(o, \" \"), s], \" \");\n      },\n      Argument: function (e) {\n        return e.name + \": \" + e.value;\n      },\n      FragmentSpread: function (e) {\n        return \"...\" + e.name + a(\" \", r(e.directives, \" \"));\n      },\n      InlineFragment: function (e) {\n        var n = e.typeCondition,\n            t = e.directives,\n            i = e.selectionSet;\n        return r([\"...\", a(\"on \", n), r(t, \" \"), i], \" \");\n      },\n      FragmentDefinition: function (e) {\n        var n = e.name,\n            t = e.typeCondition,\n            i = e.variableDefinitions,\n            o = e.directives,\n            s = e.selectionSet;\n        return \"fragment \".concat(n).concat(a(\"(\", r(i, \", \"), \")\"), \" \") + \"on \".concat(t, \" \").concat(a(\"\", r(o, \" \"), \" \")) + s;\n      },\n      IntValue: function (e) {\n        return e.value;\n      },\n      FloatValue: function (e) {\n        return e.value;\n      },\n      StringValue: function (e, n) {\n        var t = e.value;\n        return e.block ? (0, y.printBlockString)(t, \"description\" === n ? \"\" : \"  \") : JSON.stringify(t);\n      },\n      BooleanValue: function (e) {\n        return e.value ? \"true\" : \"false\";\n      },\n      NullValue: function () {\n        return \"null\";\n      },\n      EnumValue: function (e) {\n        return e.value;\n      },\n      ListValue: function (e) {\n        return \"[\" + r(e.values, \", \") + \"]\";\n      },\n      ObjectValue: function (e) {\n        return \"{\" + r(e.fields, \", \") + \"}\";\n      },\n      ObjectField: function (e) {\n        return e.name + \": \" + e.value;\n      },\n      Directive: function (e) {\n        return \"@\" + e.name + a(\"(\", r(e.arguments, \", \"), \")\");\n      },\n      NamedType: function (e) {\n        return e.name;\n      },\n      ListType: function (e) {\n        return \"[\" + e.type + \"]\";\n      },\n      NonNullType: function (e) {\n        return e.type + \"!\";\n      },\n      SchemaDefinition: function (e) {\n        var n = e.directives,\n            t = e.operationTypes;\n        return r([\"schema\", r(n, \" \"), o(t)], \" \");\n      },\n      OperationTypeDefinition: function (e) {\n        return e.operation + \": \" + e.type;\n      },\n      ScalarTypeDefinition: i(function (e) {\n        return r([\"scalar\", e.name, r(e.directives, \" \")], \" \");\n      }),\n      ObjectTypeDefinition: i(function (e) {\n        var n = e.name,\n            t = e.interfaces,\n            i = e.directives,\n            s = e.fields;\n        return r([\"type\", n, a(\"implements \", r(t, \" & \")), r(i, \" \"), o(s)], \" \");\n      }),\n      FieldDefinition: i(function (e) {\n        var n = e.name,\n            t = e.arguments,\n            i = e.type,\n            o = e.directives;\n        return n + (u(t) ? a(\"(\\n\", s(r(t, \"\\n\")), \"\\n)\") : a(\"(\", r(t, \", \"), \")\")) + \": \" + i + a(\" \", r(o, \" \"));\n      }),\n      InputValueDefinition: i(function (e) {\n        var n = e.name,\n            t = e.type,\n            i = e.defaultValue,\n            o = e.directives;\n        return r([n + \": \" + t, a(\"= \", i), r(o, \" \")], \" \");\n      }),\n      InterfaceTypeDefinition: i(function (e) {\n        var n = e.name,\n            t = e.directives,\n            i = e.fields;\n        return r([\"interface\", n, r(t, \" \"), o(i)], \" \");\n      }),\n      UnionTypeDefinition: i(function (e) {\n        var n = e.name,\n            t = e.directives,\n            i = e.types;\n        return r([\"union\", n, r(t, \" \"), i && 0 !== i.length ? \"= \" + r(i, \" | \") : \"\"], \" \");\n      }),\n      EnumTypeDefinition: i(function (e) {\n        var n = e.name,\n            t = e.directives,\n            i = e.values;\n        return r([\"enum\", n, r(t, \" \"), o(i)], \" \");\n      }),\n      EnumValueDefinition: i(function (e) {\n        return r([e.name, r(e.directives, \" \")], \" \");\n      }),\n      InputObjectTypeDefinition: i(function (e) {\n        var n = e.name,\n            t = e.directives,\n            i = e.fields;\n        return r([\"input\", n, r(t, \" \"), o(i)], \" \");\n      }),\n      DirectiveDefinition: i(function (e) {\n        var n = e.name,\n            t = e.arguments,\n            i = e.repeatable,\n            o = e.locations;\n        return \"directive @\" + n + (u(t) ? a(\"(\\n\", s(r(t, \"\\n\")), \"\\n)\") : a(\"(\", r(t, \", \"), \")\")) + (i ? \" repeatable\" : \"\") + \" on \" + r(o, \" | \");\n      }),\n      SchemaExtension: function (e) {\n        var n = e.directives,\n            t = e.operationTypes;\n        return r([\"extend schema\", r(n, \" \"), o(t)], \" \");\n      },\n      ScalarTypeExtension: function (e) {\n        return r([\"extend scalar\", e.name, r(e.directives, \" \")], \" \");\n      },\n      ObjectTypeExtension: function (e) {\n        var n = e.name,\n            t = e.interfaces,\n            i = e.directives,\n            s = e.fields;\n        return r([\"extend type\", n, a(\"implements \", r(t, \" & \")), r(i, \" \"), o(s)], \" \");\n      },\n      InterfaceTypeExtension: function (e) {\n        var n = e.name,\n            t = e.directives,\n            i = e.fields;\n        return r([\"extend interface\", n, r(t, \" \"), o(i)], \" \");\n      },\n      UnionTypeExtension: function (e) {\n        var n = e.name,\n            t = e.directives,\n            i = e.types;\n        return r([\"extend union\", n, r(t, \" \"), i && 0 !== i.length ? \"= \" + r(i, \" | \") : \"\"], \" \");\n      },\n      EnumTypeExtension: function (e) {\n        var n = e.name,\n            t = e.directives,\n            i = e.values;\n        return r([\"extend enum\", n, r(t, \" \"), o(i)], \" \");\n      },\n      InputObjectTypeExtension: function (e) {\n        var n = e.name,\n            t = e.directives,\n            i = e.fields;\n        return r([\"extend input\", n, r(t, \" \"), o(i)], \" \");\n      }\n    };\n\n    function i(e) {\n      return function (n) {\n        return r([n.description, e(n)], \"\\n\");\n      };\n    }\n\n    function r(e, n) {\n      return e ? e.filter(function (e) {\n        return e;\n      }).join(n || \"\") : \"\";\n    }\n\n    function o(e) {\n      return e && 0 !== e.length ? \"{\\n\" + s(r(e, \"\\n\")) + \"\\n}\" : \"\";\n    }\n\n    function a(e, n, t) {\n      return n ? e + n + (t || \"\") : \"\";\n    }\n\n    function s(e) {\n      return e && \"  \" + e.replace(/\\n/g, \"\\n  \");\n    }\n\n    function c(e) {\n      return -1 !== e.indexOf(\"\\n\");\n    }\n\n    function u(e) {\n      return e && e.some(c);\n    }\n  });\n  r(O);\n  O.print;\n  var D = o(function (e, n) {\n    function t(e) {\n      return e.kind === d.Kind.OPERATION_DEFINITION || e.kind === d.Kind.FRAGMENT_DEFINITION;\n    }\n\n    function i(e) {\n      return e.kind === d.Kind.SCHEMA_DEFINITION || r(e) || e.kind === d.Kind.DIRECTIVE_DEFINITION;\n    }\n\n    function r(e) {\n      return e.kind === d.Kind.SCALAR_TYPE_DEFINITION || e.kind === d.Kind.OBJECT_TYPE_DEFINITION || e.kind === d.Kind.INTERFACE_TYPE_DEFINITION || e.kind === d.Kind.UNION_TYPE_DEFINITION || e.kind === d.Kind.ENUM_TYPE_DEFINITION || e.kind === d.Kind.INPUT_OBJECT_TYPE_DEFINITION;\n    }\n\n    function o(e) {\n      return e.kind === d.Kind.SCHEMA_EXTENSION || a(e);\n    }\n\n    function a(e) {\n      return e.kind === d.Kind.SCALAR_TYPE_EXTENSION || e.kind === d.Kind.OBJECT_TYPE_EXTENSION || e.kind === d.Kind.INTERFACE_TYPE_EXTENSION || e.kind === d.Kind.UNION_TYPE_EXTENSION || e.kind === d.Kind.ENUM_TYPE_EXTENSION || e.kind === d.Kind.INPUT_OBJECT_TYPE_EXTENSION;\n    }\n\n    Object.defineProperty(n, \"__esModule\", {\n      value: !0\n    }), n.isDefinitionNode = function (e) {\n      return t(e) || i(e) || o(e);\n    }, n.isExecutableDefinitionNode = t, n.isSelectionNode = function (e) {\n      return e.kind === d.Kind.FIELD || e.kind === d.Kind.FRAGMENT_SPREAD || e.kind === d.Kind.INLINE_FRAGMENT;\n    }, n.isValueNode = function (e) {\n      return e.kind === d.Kind.VARIABLE || e.kind === d.Kind.INT || e.kind === d.Kind.FLOAT || e.kind === d.Kind.STRING || e.kind === d.Kind.BOOLEAN || e.kind === d.Kind.NULL || e.kind === d.Kind.ENUM || e.kind === d.Kind.LIST || e.kind === d.Kind.OBJECT;\n    }, n.isTypeNode = function (e) {\n      return e.kind === d.Kind.NAMED_TYPE || e.kind === d.Kind.LIST_TYPE || e.kind === d.Kind.NON_NULL_TYPE;\n    }, n.isTypeSystemDefinitionNode = i, n.isTypeDefinitionNode = r, n.isTypeSystemExtensionNode = o, n.isTypeExtensionNode = a;\n  });\n  r(D);\n  D.isDefinitionNode, D.isExecutableDefinitionNode, D.isSelectionNode, D.isValueNode, D.isTypeNode, D.isTypeSystemDefinitionNode, D.isTypeDefinitionNode, D.isTypeSystemExtensionNode, D.isTypeExtensionNode;\n  var x = o(function (e, n) {\n    Object.defineProperty(n, \"__esModule\", {\n      value: !0\n    }), Object.defineProperty(n, \"Source\", {\n      enumerable: !0,\n      get: function () {\n        return c.Source;\n      }\n    }), Object.defineProperty(n, \"getLocation\", {\n      enumerable: !0,\n      get: function () {\n        return u.getLocation;\n      }\n    }), Object.defineProperty(n, \"printLocation\", {\n      enumerable: !0,\n      get: function () {\n        return l.printLocation;\n      }\n    }), Object.defineProperty(n, \"printSourceLocation\", {\n      enumerable: !0,\n      get: function () {\n        return l.printSourceLocation;\n      }\n    }), Object.defineProperty(n, \"Kind\", {\n      enumerable: !0,\n      get: function () {\n        return d.Kind;\n      }\n    }), Object.defineProperty(n, \"TokenKind\", {\n      enumerable: !0,\n      get: function () {\n        return p.TokenKind;\n      }\n    }), Object.defineProperty(n, \"createLexer\", {\n      enumerable: !0,\n      get: function () {\n        return N.createLexer;\n      }\n    }), Object.defineProperty(n, \"parse\", {\n      enumerable: !0,\n      get: function () {\n        return I.parse;\n      }\n    }), Object.defineProperty(n, \"parseValue\", {\n      enumerable: !0,\n      get: function () {\n        return I.parseValue;\n      }\n    }), Object.defineProperty(n, \"parseType\", {\n      enumerable: !0,\n      get: function () {\n        return I.parseType;\n      }\n    }), Object.defineProperty(n, \"print\", {\n      enumerable: !0,\n      get: function () {\n        return O.print;\n      }\n    }), Object.defineProperty(n, \"visit\", {\n      enumerable: !0,\n      get: function () {\n        return _.visit;\n      }\n    }), Object.defineProperty(n, \"visitInParallel\", {\n      enumerable: !0,\n      get: function () {\n        return _.visitInParallel;\n      }\n    }), Object.defineProperty(n, \"visitWithTypeInfo\", {\n      enumerable: !0,\n      get: function () {\n        return _.visitWithTypeInfo;\n      }\n    }), Object.defineProperty(n, \"getVisitFn\", {\n      enumerable: !0,\n      get: function () {\n        return _.getVisitFn;\n      }\n    }), Object.defineProperty(n, \"BREAK\", {\n      enumerable: !0,\n      get: function () {\n        return _.BREAK;\n      }\n    }), Object.defineProperty(n, \"isDefinitionNode\", {\n      enumerable: !0,\n      get: function () {\n        return D.isDefinitionNode;\n      }\n    }), Object.defineProperty(n, \"isExecutableDefinitionNode\", {\n      enumerable: !0,\n      get: function () {\n        return D.isExecutableDefinitionNode;\n      }\n    }), Object.defineProperty(n, \"isSelectionNode\", {\n      enumerable: !0,\n      get: function () {\n        return D.isSelectionNode;\n      }\n    }), Object.defineProperty(n, \"isValueNode\", {\n      enumerable: !0,\n      get: function () {\n        return D.isValueNode;\n      }\n    }), Object.defineProperty(n, \"isTypeNode\", {\n      enumerable: !0,\n      get: function () {\n        return D.isTypeNode;\n      }\n    }), Object.defineProperty(n, \"isTypeSystemDefinitionNode\", {\n      enumerable: !0,\n      get: function () {\n        return D.isTypeSystemDefinitionNode;\n      }\n    }), Object.defineProperty(n, \"isTypeDefinitionNode\", {\n      enumerable: !0,\n      get: function () {\n        return D.isTypeDefinitionNode;\n      }\n    }), Object.defineProperty(n, \"isTypeSystemExtensionNode\", {\n      enumerable: !0,\n      get: function () {\n        return D.isTypeSystemExtensionNode;\n      }\n    }), Object.defineProperty(n, \"isTypeExtensionNode\", {\n      enumerable: !0,\n      get: function () {\n        return D.isTypeExtensionNode;\n      }\n    }), Object.defineProperty(n, \"DirectiveLocation\", {\n      enumerable: !0,\n      get: function () {\n        return k.DirectiveLocation;\n      }\n    });\n  });\n  r(x);\n  var K = o(function (e, n) {\n    Object.defineProperty(n, \"__esModule\", {\n      value: !0\n    }), n.locatedError = function (e, n, t) {\n      if (e && Array.isArray(e.path)) return e;\n      return new v.GraphQLError(e && e.message, e && e.nodes || n, e && e.source, e && e.positions, t, e);\n    };\n  });\n  r(K);\n  K.locatedError;\n  var A = o(function (e, n) {\n    Object.defineProperty(n, \"__esModule\", {\n      value: !0\n    }), n.formatError = function (e) {\n      e || (0, i.default)(0, \"Received null or undefined error.\");\n      var n = e.message || \"An unknown error occurred.\",\n          t = e.locations,\n          r = e.path,\n          o = e.extensions;\n      return o ? {\n        message: n,\n        locations: t,\n        path: r,\n        extensions: o\n      } : {\n        message: n,\n        locations: t,\n        path: r\n      };\n    };\n    var t,\n        i = (t = a) && t.__esModule ? t : {\n      default: t\n    };\n  });\n  r(A);\n  A.formatError;\n  var b = o(function (e, n) {\n    Object.defineProperty(n, \"__esModule\", {\n      value: !0\n    }), Object.defineProperty(n, \"GraphQLError\", {\n      enumerable: !0,\n      get: function () {\n        return v.GraphQLError;\n      }\n    }), Object.defineProperty(n, \"printError\", {\n      enumerable: !0,\n      get: function () {\n        return v.printError;\n      }\n    }), Object.defineProperty(n, \"syntaxError\", {\n      enumerable: !0,\n      get: function () {\n        return E.syntaxError;\n      }\n    }), Object.defineProperty(n, \"locatedError\", {\n      enumerable: !0,\n      get: function () {\n        return K.locatedError;\n      }\n    }), Object.defineProperty(n, \"formatError\", {\n      enumerable: !0,\n      get: function () {\n        return A.formatError;\n      }\n    });\n  });\n  r(b);\n  var S = {\n    parsers: {\n      graphql: {\n        parse: function (e) {\n          var i = x;\n\n          try {\n            var r = function (e, n) {\n              var t = {\n                allowLegacySDLImplementsInterfaces: !1,\n                experimentalFragmentVariables: !0\n              };\n\n              try {\n                return e(n, t);\n              } catch (i) {\n                return t.allowLegacySDLImplementsInterfaces = !0, e(n, t);\n              }\n            }(i.parse, e);\n\n            return r.comments = function (e) {\n              for (var n = [], t = e.loc.startToken.next; \"<EOF>\" !== t.kind;) \"Comment\" === t.kind && (Object.assign(t, {\n                column: t.column - 1\n              }), n.push(t)), t = t.next;\n\n              return n;\n            }(r), function e(t) {\n              if (t && \"object\" === n(t)) for (var i in delete t.startToken, delete t.endToken, delete t.prev, delete t.next, t) e(t[i]);\n              return t;\n            }(r), r;\n          } catch (e) {\n            throw e instanceof b.GraphQLError ? t(e.message, {\n              start: {\n                line: e.locations[0].line,\n                column: e.locations[0].column\n              }\n            }) : e;\n          }\n        },\n        astFormat: \"graphql\",\n        hasPragma: i,\n        locStart: function (e) {\n          return \"number\" == typeof e.start ? e.start : e.loc && e.loc.start;\n        },\n        locEnd: function (e) {\n          return \"number\" == typeof e.end ? e.end : e.loc && e.loc.end;\n        }\n      }\n    }\n  },\n      g = S.parsers;\n  e.default = S, e.parsers = g, Object.defineProperty(e, \"__esModule\", {\n    value: !0\n  });\n});","map":null,"metadata":{},"sourceType":"script"}